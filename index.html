<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>可爱茶铺 - 农场管理系统 (GitHub Pages版)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #ffffff;
            color: #374151;
            line-height: 1.4;
            font-size: 12px;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 15px; }
        .header { text-align: center; margin-bottom: 20px; }
        .header h1 { font-size: 16px; color: #374151; margin-bottom: 8px; font-weight: 500; }
        .section { margin-bottom: 25px; }
        .section-title { font-size: 12px; font-weight: 500; margin-bottom: 10px; color: #374151; }
        
        /* 调试窗口样式 */
        .debug-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 400px;
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            z-index: 1000;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        /* 调试面板折叠状态 */
        .debug-panel.collapsed {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            bottom: 20px;
            top: auto;
            right: 20px;
        }

        .debug-panel.collapsed:hover {
            background: #2563eb;
            transform: scale(1.1);
        }
        .debug-header {
            background: #3b82f6;
            color: white;
            padding: 10px 15px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 6px 6px 0 0;
        }

        /* 折叠状态下的header样式 */
        .debug-panel.collapsed .debug-header {
            background: transparent;
            padding: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            justify-content: center;
        }

        .debug-panel.collapsed .debug-header span {
            font-size: 24px;
            color: white;
        }

        /* 圆球状态下只显示第一个emoji */
        .debug-panel.collapsed .debug-header span::before {
            content: '🛠';
            font-size: 24px;
        }

        .debug-panel.collapsed .debug-header span {
            text-indent: -9999px;
            position: relative;
        }

        .debug-panel.collapsed .debug-header span::before {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            text-indent: 0;
        }
        .debug-toggle {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
        }

        /* 折叠状态下隐藏内容和toggle按钮 */
        .debug-panel.collapsed .debug-content,
        .debug-panel.collapsed .debug-toggle {
            display: none;
        }
        .debug-content {
            padding: 15px;
            font-size: 12px;
        }
        .debug-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e5e7eb;
        }
        .debug-section:last-child {
            border-bottom: none;
        }
        .debug-section h4 {
            color: #6b7280;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .debug-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .debug-status {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        .status-connected { background: #e5e7eb; color: #6b7280; }
        .status-disconnected { background: #e5e7eb; color: #6b7280; }
        .status-loading { background: #e5e7eb; color: #6b7280; }
        .debug-actions {
            display: flex;
            flex-wrap: nowrap;
            gap: 5px;
            margin-top: 10px;
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 5px;
            white-space: nowrap;
            max-width: 100%;
        }

        .debug-actions::-webkit-scrollbar {
            height: 6px;
        }

        .debug-actions::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .debug-actions::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        .debug-actions::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .debug-btn {
            padding: 5px 10px;
            background: #e5e7eb;
            color: #4b5563;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .debug-btn:hover {
            background: #f3f4f6;
        }

        /* GitHub Pages版本标识 */
        .github-badge {
            position: fixed;
            top: 10px;
            left: 10px;
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
            z-index: 1001;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
        }
        .debug-log {
            max-height: 100px;
            overflow-y: auto;
            background: #f9fafb;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 10px;
            line-height: 1.4;
        }
        
        /* 基础数据表格 */
        .basic-info-table {
            width: 100%;
            border-collapse: collapse;
            border: 1px solid #e5e7eb;
            margin-bottom: 15px;
            background: #ffffff;
        }
        .basic-info-table th, .basic-info-table td {
            border: 1px solid #e5e7eb;
            padding: 8px;
            text-align: left;
            color: #374151;
            font-size: 12px;
        }
        .basic-info-table th { background-color: #f9fafb; font-weight: 500; }
        
        /* 种植区域 */
        .farm-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; }
        .plot-card {
            border: 1px solid #e5e7eb;
            background: #ffffff;
            padding: 15px;
            border-radius: 6px;
        }
        .plot-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .plot-title { font-weight: 500; color: #374151; font-size: 12px; }
        .plot-status {
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 400;
        }
        .status-empty { background-color: #f3f4f6; color: #6b7280; }
        .status-growing { background-color: #e5e7eb; color: #6b7280; }
        .status-ready { background-color: #e5e7eb; color: #6b7280; }
        
        .conditions-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
        }
        .conditions-table td {
            padding: 6px;
            border: 1px solid #e5e7eb;
            font-size: 12px;
        }
        .progress-bar {
            width: 100%;
            height: 16px;
            background-color: #f3f4f6;
            border-radius: 8px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        .moisture-fill { background-color: #d1d5db; }
        .fertility-fill { background-color: #d1d5db; }
        .growth-fill { background-color: #9ca3af; }
        
        .plot-actions { display: flex; gap: 8px; margin-top: 12px; }
        .action-btn {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            background: #ffffff;
            color: #374151;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        .action-btn:hover { background-color: #f9fafb; border-color: #9ca3af; }
        .action-btn.primary { background-color: #f3f4f6; color: #374151; border-color: #d1d5db; }
        .action-btn.primary:hover { background-color: #e5e7eb; }
        
        /* 工作区域表格 */
        .workspace-table {
            width: 100%;
            border-collapse: collapse;
            border: 1px solid #e5e7eb;
            margin-bottom: 15px;
        }
        .workspace-table th, .workspace-table td {
            border: 1px solid #e5e7eb;
            padding: 8px;
            text-align: left;
            font-size: 12px;
        }
        .workspace-table th { background-color: #f9fafb; font-weight: 500; color: #374151; }
        
        /* 小料商店样式 */
        .toppings-shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }
        .topping-item {
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 12px;
            background: #ffffff;
            text-align: center;
            transition: all 0.2s ease;
        }
        .topping-item:hover {
            border-color: #9ca3af;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
        }
        .topping-icon {
            display: none;
        }
        .topping-name {
            font-weight: 500;
            margin-bottom: 4px;
            color: #374151;
            font-size: 12px;
        }
        .topping-price {
            color: #6b7280;
            font-weight: 400;
            margin-bottom: 4px;
            font-size: 12px;
        }
        .topping-stock {
            color: #6b7280;
            font-size: 12px;
            margin-bottom: 8px;
        }
        .topping-description {
            color: #9ca3af;
            font-size: 12px;
            margin-bottom: 8px;
            line-height: 1.3;
        }
        .buy-btn {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            background: #ffffff;
            color: #374151;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        .buy-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }
        .buy-btn:disabled {
            background: #f3f4f6;
            border-color: #e5e7eb;
            color: #9ca3af;
            cursor: not-allowed;
        }

        /* 库存表格 */
        .inventory-table {
            width: 100%;
            border-collapse: collapse;
            border: 1px solid #e5e7eb;
        }
        .inventory-table th, .inventory-table td {
            border: 1px solid #e5e7eb;
            padding: 6px;
            text-align: center;
            font-size: 12px;
        }
        .inventory-table th { background-color: #f9fafb; font-weight: 500; color: #374151; }
        
        /* 模态框样式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            width: 80%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            font-size: 12px;
        }
        .close {
            color: #9ca3af;
            float: right;
            font-size: 18px;
            font-weight: normal;
            cursor: pointer;
        }
        .close:hover { color: #374151; }
        
        .seed-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); 
            gap: 10px; 
            margin-top: 15px; 
        }
        .seed-option {
            border: 1px solid #e5e7eb;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            background: #ffffff;
            transition: all 0.2s ease;
        }
        .seed-option:hover { background-color: #f9fafb; border-color: #9ca3af; }
        .seed-name { font-weight: 500; margin-bottom: 3px; color: #374151; font-size: 12px; }
        .seed-info { font-size: 12px; color: #6b7280; }

        /* 顾客系统样式 */
        .customer-visit-area {
            background-color: #f9fafb;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }

        .current-customer-display {
            background-color: white;
            padding: 12px;
            margin: 8px 0;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
            min-height: 80px;
            font-size: 12px;
        }

        .customer-avatar {
            display: none;
        }

        /* 顶部菜单栏样式 */
        .top-menu-bar {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 8px 15px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
        }

        .menu-item {
            position: relative;
            display: inline-block;
        }

        .menu-btn {
            background: #3b82f6;
            border: 1px solid #2563eb;
            color: #ffffff;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s ease;
        }

        .menu-btn:hover {
            background: #2563eb;
            border-color: #1d4ed8;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #ffffff;
            min-width: 140px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            z-index: 1000;
            top: 100%;
            left: 0;
            margin-top: 2px;
        }

        .dropdown-content a {
            color: #374151;
            padding: 8px 12px;
            text-decoration: none;
            display: block;
            font-size: 12px;
            border-bottom: 1px solid #f3f4f6;
        }

        .dropdown-content a:last-child {
            border-bottom: none;
        }

        .dropdown-content a:hover {
            background-color: #f9fafb;
            color: #374151;
        }

        .dropdown-content.show {
            display: block;
        }

        /* 行列布局 */
        .row {
            display: flex;
            flex-wrap: wrap;
            margin: 0 -10px;
        }

        .col-6 {
            flex: 0 0 50%;
            max-width: 50%;
            padding: 0 10px;
        }

        /* 移动端适配 */
        @media (max-width: 768px) {
            .col-6 {
                flex: 0 0 100%;
                max-width: 100%;
            }

            .container {
                padding: 10px;
            }

            .debug-panel {
                width: 90%;
                right: 5%;
                top: 5px;
                max-height: 80vh;
                overflow-y: auto;
            }

            .debug-content {
                max-height: 70vh;
                overflow-y: auto;
                padding: 10px;
            }

            .debug-panel.collapsed {
                width: 50px;
                height: 50px;
                right: 15px;
                bottom: 15px;
            }

            .github-badge {
                font-size: 10px;
                padding: 6px 12px;
                top: 5px;
                left: 5px;
            }

            .basic-info-table th,
            .basic-info-table td {
                padding: 6px 8px;
                font-size: 11px;
            }

            .workspace-table th,
            .workspace-table td {
                padding: 6px 8px;
                font-size: 11px;
            }

            .inventory-table th,
            .inventory-table td {
                padding: 6px 8px;
                font-size: 11px;
            }

            .action-btn {
                padding: 6px 10px;
                font-size: 11px;
            }

            .top-menu-bar {
                flex-wrap: wrap;
                gap: 8px;
            }

            .menu-btn {
                font-size: 11px;
                padding: 6px 12px;
            }

            /* 移动端调试按钮优化 */
            .debug-actions {
                flex-wrap: wrap !important;
                max-height: 200px;
                overflow-y: auto;
                overflow-x: hidden;
            }

            .debug-btn {
                flex: 0 0 calc(50% - 3px);
                margin-bottom: 6px;
                font-size: 10px;
                padding: 8px 6px;
                text-align: center;
            }

            /* 调试面板滚动条样式 */
            .debug-content::-webkit-scrollbar,
            .debug-actions::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }

            .debug-content::-webkit-scrollbar-track,
            .debug-actions::-webkit-scrollbar-track {
                background: #f1f1f1;
                border-radius: 4px;
            }

            .debug-content::-webkit-scrollbar-thumb,
            .debug-actions::-webkit-scrollbar-thumb {
                background: #888;
                border-radius: 4px;
            }

            .debug-content::-webkit-scrollbar-thumb:hover,
            .debug-actions::-webkit-scrollbar-thumb:hover {
                background: #555;
            }
        }

        /* 天气图标灰色样式 */
        .weather-icon {
            filter: grayscale(100%);
            opacity: 0.7;
        }

        /* 存档槽位样式 */
        .save-slot {
            padding: 8px 12px;
            border-bottom: 1px solid #e5e7eb;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .save-slot:hover {
            background-color: #f3f4f6;
        }

        .save-slot:last-child {
            border-bottom: none;
        }

        .save-slot-header {
            font-weight: 600;
            color: #374151;
            font-size: 12px;
            margin-bottom: 2px;
        }

        .save-slot-time {
            font-size: 10px;
            color: #6b7280;
        }

        /* 可折叠表格样式 */
        .collapsible-section {
            display: none;
        }

        .collapsible-section.active {
            display: block;
            /* 将活动的折叠区域移动到顶部 */
            order: -1;
        }

        .main-content-wrapper {
            display: flex;
            flex-direction: column;
        }



        /* 进度条样式 */
        .progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: #f3f4f6;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: #e5e7eb;
            border-radius: 9px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: 500;
            color: #374151;
            text-shadow: 0 1px 2px rgba(255,255,255,0.8);
            z-index: 1;
        }

        .progress-bar.cooking {
            background: #e5e7eb;
        }

        .progress-bar.processing {
            background: #e5e7eb;
        }

        /* 种植区域小进度条样式 */
        .plot-progress-container {
            width: 100%;
            height: 8px;
            background-color: #f3f4f6;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
            overflow: hidden;
            position: relative;
            margin: 2px 0;
        }

        .plot-progress-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
            position: relative;
        }

        .plot-progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8px;
            font-weight: 500;
            color: #374151;
            text-shadow: 0 1px 2px rgba(255,255,255,0.8);
            z-index: 1;
            line-height: 1;
        }

        .moisture-progress {
            background: #e5e7eb;
        }

        .fertility-progress {
            background: #e5e7eb;
        }

        .growth-progress {
            background: #e5e7eb;
        }

        .customer-name {
            font-weight: 600;
            color: #495057;
            margin-bottom: 5px;
        }

        .customer-status {
            font-size: 12px;
            color: #6c757d;
        }

        /* 猫咪系统样式 */
        .cat-interaction-area {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .selected-cat-display {
            background-color: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            min-height: 120px;
        }

        .cat-avatar {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .cat-name {
            font-weight: 600;
            color: #495057;
            margin-bottom: 5px;
        }

        .cat-intimacy {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 5px;
        }

        .intimacy-bar {
            width: 100%;
            height: 10px;
            background-color: #f3f4f6;
            border-radius: 5px;
            overflow: hidden;
            margin: 5px 0;
            border: 1px solid #d1d5db;
        }

        /* Badge 样式 */
        .badge {
            display: inline-block;
            padding: 4px 8px;
            font-size: 11px;
            font-weight: 600;
            line-height: 1;
            text-align: center;
            white-space: nowrap;
            vertical-align: baseline;
            border-radius: 4px;
        }
        .bg-warning { background-color: #e5e7eb; color: #6b7280; }
        .bg-success { background-color: #e5e7eb; color: #4b5563; }
        .bg-info { background-color: #e5e7eb; color: #6b7280; }
        .bg-secondary { background-color: #e5e7eb; color: #6b7280; }

        /* Progress 样式 */
        .progress {
            display: flex;
            height: 8px;
            overflow: hidden;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        .progress-bar {
            display: flex;
            flex-direction: column;
            justify-content: center;
            color: white;
            text-align: center;
            background-color: #e5e7eb;
            transition: width 0.6s ease;
        }
        .progress-bar.bg-warning {
            background-color: #6b7280; /* 灰色 */
            background-image: linear-gradient(45deg, rgba(255,255,255,.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,.15) 50%, rgba(255,255,255,.15) 75%, transparent 75%, transparent);
            background-size: 1rem 1rem;
        }
        .progress-bar.bg-success {
            background-color: #6b7280; /* 灰色 */
            background-image: linear-gradient(45deg, rgba(255,255,255,.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,.15) 50%, rgba(255,255,255,.15) 75%, transparent 75%, transparent);
            background-size: 1rem 1rem;
        }

        /* Alert 样式 */
        .alert {
            position: relative;
            padding: 12px 16px;
            margin-bottom: 16px;
            border: 1px solid transparent;
            border-radius: 4px;
        }
        .alert-info { color: #6b7280; background-color: #e5e7eb; border-color: #d1d5db; }
        .alert-warning { color: #6b7280; background-color: #e5e7eb; border-color: #d1d5db; }
        .alert-secondary { color: #6b7280; background-color: #e5e7eb; border-color: #d1d5db; }

        /* 工具类 */
        .text-center { text-align: center; }
        .text-end { text-align: right; }
        .text-muted { color: #6c757d; }
        .mt-3 { margin-top: 16px; }

        .intimacy-progress {
            height: 100%;
            background-color: #6b7280; /* 灰色 */
            border-radius: 4px;
            transition: width 0.3s ease;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }

        .cat-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .cat-actions .action-btn {
            flex: 1;
        }

        /* Win95风格弹窗系统 */
        .win95-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(2px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .win95-modal {
            background: #c0c0c0;
            border: 2px outset #c0c0c0;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            min-width: 300px;
            max-width: 500px;
            font-family: 'MS Sans Serif', sans-serif;
            font-size: 11px;
        }

        .win95-modal-header {
            background: linear-gradient(90deg, #0080ff 0%, #0040c0 100%);
            color: white;
            padding: 2px 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 11px;
        }

        .win95-modal-title {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .win95-modal-close {
            background: #c0c0c0;
            border: 1px outset #c0c0c0;
            width: 16px;
            height: 14px;
            font-size: 9px;
            line-height: 1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: black;
        }

        .win95-modal-close:hover {
            background: #e0e0e0;
        }

        .win95-modal-close:active {
            border: 1px inset #c0c0c0;
        }

        .win95-modal-content {
            background: #c0c0c0;
            padding: 12px;
            border-top: 1px solid #808080;
            color: #000;
            line-height: 1.4;
        }

        .win95-modal-buttons {
            background: #c0c0c0;
            padding: 8px 12px;
            border-top: 1px solid #808080;
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        .win95-button {
            background: #c0c0c0;
            border: 1px outset #c0c0c0;
            padding: 2px 16px;
            font-size: 11px;
            font-family: 'MS Sans Serif', sans-serif;
            cursor: pointer;
            min-width: 60px;
            height: 23px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .win95-button:hover {
            background: #e0e0e0;
        }

        .win95-button:active {
            border: 1px inset #c0c0c0;
        }

        .win95-button.primary {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- GitHub Pages版本标识 -->
    <div class="github-badge">
        🚀 GitHub Pages版
    </div>

    <!-- 调试面板 -->
    <div class="debug-panel collapsed" id="debug-panel">
        <div class="debug-header" onclick="toggleDebugContent()">
            <span>🔧 调试控制台 <small style="opacity: 0.7;">(可滚动)</small></span>
            <button class="debug-toggle" onclick="event.stopPropagation(); toggleDebugContent()">−</button>
        </div>
        <div class="debug-content" id="debug-content">
            <div class="debug-section">
                <h4>存储状态 (GitHub Pages版)</h4>
                <div class="debug-item">
                    <span>本地存储:</span>
                    <span class="debug-status status-connected" id="db-status">localStorage</span>
                </div>
                <div class="debug-item">
                    <span>云端存档:</span>
                    <span class="debug-status status-loading" id="cloud-status">未设置</span>
                </div>
                <div class="debug-item">
                    <span>最后保存:</span>
                    <span id="last-save">未保存</span>
                </div>
                <div class="debug-item">
                    <span>版本:</span>
                    <span>GitHub Pages v1.0</span>
                </div>
            </div>
            
            <div class="debug-section">
                <h4>游戏数据概览</h4>
                <div class="debug-item">
                    <span>游戏天数:</span>
                    <span id="debug-day">第1天</span>
                </div>
                <div class="debug-item">
                    <span>当前季节:</span>
                    <span id="debug-season">🌸 春天 (第1天)</span>
                </div>
                <div class="debug-item">
                    <span>当前天气:</span>
                    <span id="debug-weather">☀️ 晴天</span>
                </div>
                <div class="debug-item">
                    <span>资金:</span>
                    <span id="debug-funds">100</span>
                </div>
                <div class="debug-item">
                    <span>种子总数:</span>
                    <span id="debug-seeds">0</span>
                </div>
                <div class="debug-item">
                    <span>材料总数:</span>
                    <span id="debug-materials">0</span>
                </div>
                <div class="debug-item">
                    <span>服务顾客数:</span>
                    <span id="debug-served-customers">0</span>
                </div>
                <div class="debug-item">
                    <span>小料总数:</span>
                    <span id="debug-toppings">0</span>
                </div>
            </div>
            
            <div class="debug-section">
                <h4>种植状态</h4>
                <div id="debug-plots">
                    <!-- 种植状态动态显示 -->
                </div>
            </div>
            
            <div class="debug-section">
                <h4>操作日志</h4>
                <div class="debug-log" id="debug-log">
                    系统初始化...<br>
                </div>
            </div>
            
                                        <div class="debug-actions">
                                <button class="debug-btn" onclick="testLocalStorage()">测试本地存储</button>
                                <button class="debug-btn" onclick="forceSaveGame()">强制保存</button>
                                <button class="debug-btn" onclick="forceLoadGame()">强制加载</button>
                                <button class="debug-btn" onclick="clearDebugLog()">清空日志</button>
                                <button class="debug-btn" onclick="forceSpawnCustomer()">立即生成顾客</button>
                                <button class="debug-btn" onclick="addTestMaterials()">添加测试材料</button>
                                <button class="debug-btn" onclick="forceAdvanceDay()">推进一天</button>
                                <button class="debug-btn" onclick="changeWeather()">改变天气</button>
                                <button class="debug-btn" onclick="debugCustomerUnlock()">调试配方解锁</button>
                                <button class="debug-btn" onclick="syncCustomerStatsFromDatabase()">同步顾客统计</button>
                                <button class="debug-btn" onclick="testGrillUnlock()">测试烤肉架解锁</button>
                                <button class="debug-btn" onclick="showCloudSaveSettings()" style="background: #3b82f6; color: white;">☁️ 云端存档设置</button>
                                <button class="debug-btn" onclick="resetGameData()" style="background: #ef4444; color: white;">重置数据</button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>🍵 可爱茶铺 - 农场管理系统</h1>
            <p>GitHub Pages版 - 支持云端存档同步 ☁️</p>
        </div>
        
        <!-- 顶部菜单栏 -->
        <div class="top-menu-bar">
            <div class="menu-item dropdown">
                <button class="menu-btn" onclick="toggleDropdown('inventory-dropdown')">库存管理 ▼</button>
                <div id="inventory-dropdown" class="dropdown-content">
                    <a href="#" onclick="toggleInventoryTable('materials'); closeDropdown('inventory-dropdown')">原料库存</a>
                    <a href="#" onclick="toggleInventoryTable('toppings'); closeDropdown('inventory-dropdown')">小料库存管理</a>
                    <a href="#" onclick="openToppingsShop(); closeDropdown('inventory-dropdown')">小料商店</a>
                </div>
            </div>
            <div class="menu-item dropdown">
                <button class="menu-btn" onclick="toggleDropdown('customer-dropdown')">客户管理 ▼</button>
                <div id="customer-dropdown" class="dropdown-content">
                    <a href="#" onclick="toggleCustomerTable(); closeDropdown('customer-dropdown')">茶店顾客管理表</a>
                    <a href="#" onclick="showRecipeUnlockStatus(); closeDropdown('customer-dropdown')">查看配方解锁状态</a>
                </div>
            </div>
            <div class="menu-item dropdown">
                <button class="menu-btn" onclick="toggleDropdown('save-dropdown')">存档管理 ▼</button>
                <div id="save-dropdown" class="dropdown-content" style="min-width: 220px;">
                    <div class="save-slot" onclick="saveToDatabaseNow(); closeDropdown('save-dropdown')" style="background: #e8f5e8; border: 2px solid #22c55e; margin-bottom: 8px;">
                        <div class="save-slot-header" style="color: #16a34a; font-weight: bold;">💾 立即保存</div>
                        <div class="save-slot-time" style="color: #16a34a; font-size: 10px;">保存到本地存储+云端同步</div>
                    </div>
                    <div class="save-slot" onclick="loadSaveSlot(1); closeDropdown('save-dropdown')">
                        <div class="save-slot-header">槽位1 - 自动存档</div>
                        <div class="save-slot-time" id="save-time-1">未保存</div>
                    </div>
                    <div class="save-slot" onclick="handleSaveSlot(2); closeDropdown('save-dropdown')">
                        <div class="save-slot-header">槽位2</div>
                        <div class="save-slot-time" id="save-time-2">空槽位</div>
                    </div>
                    <div class="save-slot" onclick="handleSaveSlot(3); closeDropdown('save-dropdown')">
                        <div class="save-slot-header">槽位3</div>
                        <div class="save-slot-time" id="save-time-3">空槽位</div>
                    </div>
                    <div class="save-slot" onclick="handleSaveSlot(4); closeDropdown('save-dropdown')">
                        <div class="save-slot-header">槽位4</div>
                        <div class="save-slot-time" id="save-time-4">空槽位</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content-wrapper">
            <!-- 基础运营数据 -->
            <div class="section">
                <h2 class="section-title">基础运营数据</h2>
                <table class="basic-info-table">
                    <tr>
                        <th>运营天数</th>
                        <td id="current-day">1</td>
                        <th>当前季节</th>
                        <td id="current-season">春天</td>
                        <th>天气状况</th>
                        <td id="current-weather">晴天</td>
                        <th>运营资金</th>
                        <td id="current-funds">100 金币</td>
                    </tr>
                </table>
            </div>

        <!-- 顾客系统 -->
        <div id="customer-section" class="section collapsible-section">
            <h2 class="section-title">茶店顾客管理</h2>
            <table class="inventory-table">
                <thead>
                    <tr>
                        <th>顾客姓名</th>
                        <th>来访次数</th>
                        <th>解锁配方</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody id="customers-table">
                    <!-- 顾客数据 -->
                </tbody>
            </table>
        </div>

        <!-- 当前访客状态 - 始终显示 -->
        <div class="section">
            <h2 class="section-title">当前访客状态</h2>
            <div class="customer-visit-area">
                <table class="workspace-table">
                    <thead>
                        <tr>
                            <th>访客</th>
                            <th>需求</th>
                            <th>剩余时间</th>
                            <th>耐心值</th>
                        </tr>
                    </thead>
                    <tbody id="current-customer">
                        <tr>
                            <td colspan="4" class="text-center text-muted">暂无访客</td>
                        </tr>
                    </tbody>
                </table>
                <div id="customer-status" class="mt-3">
                    <div class="alert alert-secondary">等待顾客到来...</div>
                </div>
            </div>
        </div>

        <!-- 种植区域管理 -->
        <div class="section">
            <h2 class="section-title">种植区域管理</h2>
            <div class="farm-grid" id="farm-grid">
                <!-- 种植区域将通过JavaScript动态生成 -->
            </div>
        </div>

        <!-- 炉灶制茶区域和案板加工区域 -->
        <div class="section">
            <div class="row">
                <div class="col-6">
                    <h2 class="section-title">炉灶制茶区域</h2>
                    <table class="workspace-table">
                        <thead>
                            <tr>
                                <th>炉灶编号</th>
                                <th>制作配方</th>
                                <th>制作进度</th>
                                <th>操作</th>
                            </tr>
                        </thead>
                        <tbody id="stoves-table">
                            <!-- 炉灶数据将通过JavaScript生成 -->
                        </tbody>
                    </table>
                </div>
                <div class="col-6">
                    <h2 class="section-title">案板加工区域</h2>
                    <table class="workspace-table">
                        <thead>
                            <tr>
                                <th>案板编号</th>
                                <th>当前配方</th>
                                <th>加工进度</th>
                                <th>操作</th>
                            </tr>
                        </thead>
                        <tbody id="processing-table">
                            <!-- 加工台数据将通过JavaScript生成 -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- 烤肉架区域 -->
        <div class="section" id="grill-section" style="display: none;">
            <h2 class="section-title">烤肉架</h2>
            <table class="workspace-table">
                <thead>
                    <tr>
                        <th>烤肉架</th>
                        <th>烤制配方</th>
                        <th>烤制进度</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody id="grill-table">
                    <!-- 烤肉架数据将通过JavaScript生成 -->
                </tbody>
            </table>
        </div>

        <!-- 打猎区域 -->
        <div class="section" id="hunting-section" style="display: none;">
            <h2 class="section-title">打猎系统</h2>

            <!-- 后山打猎 -->
            <div class="hunting-area" style="padding: 15px; margin-bottom: 20px; border: 2px solid #ddd; border-radius: 8px;">
                <h3 style="margin: 0 0 15px 0; color: #228b22;">🏹 后山打猎</h3>
                <div class="hunting-status" id="hunting-status" style="margin-bottom: 15px;">
                    <div class="alert alert-secondary">准备打猎...</div>
                </div>
                <div class="hunting-controls" style="margin-bottom: 15px;">
                    <button class="action-btn primary" onclick="startHunting()" id="hunt-btn">
                        🏹 开始打猎 (15秒)
                    </button>
                </div>
                <div class="hunting-stats">
                    <span>打猎次数: <span id="hunt-count">0</span></span>
                    <span style="margin-left: 20px;">解锁高级猎物: <span id="advanced-hunt-status">需要50次</span></span>
                </div>
            </div>

            <!-- 山洞打猎 -->
            <div class="cave-hunting-area" id="cave-hunting-section" style="padding: 15px; border: 2px solid #8b4513; border-radius: 8px; display: none;">
                <h3 style="margin: 0 0 15px 0; color: #8b4513;">🏔️ 山洞打猎</h3>
                <div class="cave-hunting-status" id="cave-hunting-status" style="margin-bottom: 15px;">
                    <div class="alert alert-secondary">准备探索山洞...</div>
                </div>
                <div class="cave-hunting-controls" style="margin-bottom: 15px;">
                    <button class="action-btn primary" onclick="startCaveHunting()" id="cave-hunt-btn">
                        🏔️ 探索山洞 (20秒)
                    </button>
                </div>
                <div class="cave-hunting-stats">
                    <span>山洞探索次数: <span id="cave-hunt-count">0</span></span>
                    <span style="margin-left: 20px; color: #8b4513;">特产：银耳</span>
                </div>
            </div>
        </div>

        <!-- 稻香村入口 -->
        <div class="section" id="rice-village-section" style="display: none;">
            <h2 class="section-title">稻香村</h2>
            <div style="padding: 20px; text-align: center;">
                <div class="alert alert-info" style="margin-bottom: 15px;">
                    <strong>🏮 稻香村已解锁！</strong><br>
                    与猫咪伙伴一起踏上冒险之旅
                </div>
                <button class="action-btn primary" onclick="enterRiceVillage()" style="font-size: 16px; padding: 12px 24px;">
                    前往稻香村
                </button>
            </div>
        </div>

        <!-- 茶饮管理区域 -->
        <div class="section">
            <h2 class="section-title">茶饮库存管理</h2>
            <table class="inventory-table">
                <thead>
                    <tr>
                        <th>茶饮名称</th>
                        <th>温度状态</th>
                        <th>制作时间</th>
                        <th>数量</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody id="tea-inventory">
                    <!-- 茶饮库存数据 -->
                </tbody>
            </table>
        </div>

        <!-- 原料库存管理（整合版） -->
        <div id="materials-section" class="section collapsible-section">
            <h2 class="section-title">原料库存管理</h2>
            <table class="inventory-table">
                <thead>
                    <tr>
                        <th>原料名称</th>
                        <th>种子库存</th>
                        <th>材料库存</th>
                        <th>种子价格</th>
                        <th>生长时间</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody id="materials-inventory">
                    <!-- 原料库存数据 -->
                </tbody>
            </table>
        </div>

        <!-- 小料库存管理 -->
        <div id="toppings-section" class="section collapsible-section">
            <h2 class="section-title">小料库存管理</h2>
            <table class="inventory-table">
                <thead>
                    <tr>
                        <th>小料名称</th>
                        <th>当前库存</th>
                        <th>获取方式</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody id="toppings-inventory">
                    <!-- 小料库存数据 -->
                </tbody>
            </table>
        </div>

        <!-- 猫咪系统 -->
        <div class="section">
            <div class="row">
                <div class="col-6">
                    <h2 class="section-title">茶店猫咪管理</h2>
                    <table class="inventory-table">
                        <thead>
                            <tr>
                                <th>猫咪名称</th>
                                <th>亲密度</th>
                                <th>等级</th>
                                <th>礼物赠送</th>
                                <th>操作</th>
                            </tr>
                        </thead>
                        <tbody id="cats-table">
                            <tr><td colspan="5" class="text-center text-muted">猫咪数据加载中...</td></tr>
                        </tbody>
                    </table>
                </div>
                <div class="col-6">
                    <h2 class="section-title">猫咪互动</h2>
                    <div class="cat-interaction-area">
                        <div id="selected-cat" class="selected-cat-display">
                            <p>选择一只猫咪进行互动</p>
                        </div>
                        <div class="cat-actions">
                            <button class="action-btn" onclick="feedCat()">喂食茶饮</button>
                            <button class="action-btn" onclick="feedCatWithFish()">喂小鱼干</button>
                            <button class="action-btn" onclick="petCat()">撸猫</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 调试控制台浮动球 -->




    <!-- 种子购买模态框 -->
    <div id="seed-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>选择种子种植</h2>
            <div id="seed-grid" class="seed-grid">
                <!-- 种子选项将通过JavaScript生成 -->
            </div>
        </div>
    </div>

    <!-- 茶饮配方选择模态框 -->
    <div id="recipe-modal" class="modal">
        <div class="modal-content">
            <span class="close-recipe">&times;</span>
            <h2>选择茶饮配方</h2>
            <div id="recipe-grid" class="seed-grid">
                <!-- 茶饮配方选项将通过JavaScript生成 -->
            </div>
        </div>
    </div>

    <!-- 加工配方选择模态框 -->
    <div id="processing-modal" class="modal">
        <div class="modal-content">
            <span class="close-processing">&times;</span>
            <h2 style="font-size: 14px; font-weight: 500; margin-bottom: 10px;">选择加工配方</h2>
            <div id="processing-grid" class="seed-grid">
                <!-- 加工配方选项将通过JavaScript生成 -->
            </div>
        </div>
    </div>

    <!-- 小料商店模态框 -->
    <div id="toppings-shop-modal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close-toppings-shop">&times;</span>
            <h2 style="font-size: 14px; font-weight: 500; margin-bottom: 10px;">小料商店</h2>
                            <p style="margin-bottom: 15px; color: #6b7280; font-size: 12px;">当前资金: <span id="shop-funds" style="color: #374151; font-weight: 500;">1000</span> 金币</p>
            <div class="toppings-shop-grid" id="toppings-shop-grid">
                <!-- 小料商品将通过JavaScript生成 -->
            </div>
        </div>
    </div>

    <!-- Win95风格弹窗 -->
    <div class="win95-modal-overlay" id="win95-modal-overlay">
        <div class="win95-modal" id="win95-modal">
            <div class="win95-modal-header">
                <div class="win95-modal-title">
                    <span id="win95-modal-icon">ℹ️</span>
                    <span id="win95-modal-title-text">系统消息</span>
                </div>
                <div class="win95-modal-close" onclick="closeWin95Modal()">×</div>
            </div>
            <div class="win95-modal-content" id="win95-modal-content">
                消息内容
            </div>
            <div class="win95-modal-buttons" id="win95-modal-buttons">
                <button class="win95-button primary" onclick="closeWin95Modal()">确定</button>
            </div>
        </div>
    </div>

    <script>
        // GitHub Pages版本标识
        const GITHUB_PAGES_VERSION = true;
        const VERSION_INFO = {
            version: "1.0.0-github",
            build: "github-pages-optimized",
            buildTime: new Date().toISOString(),
            features: ["cloud-save", "local-storage", "multi-device", "optimized"],
            backend: false // 标识无后端依赖
        };

        console.log('🚀 可爱茶铺 GitHub Pages版本启动');
        console.log('版本信息:', VERSION_INFO);

        // 游戏数据结构
        const gameData = {
            currentDay: 1,
            seasonDay: 1,
            season: 0, // 0=春天, 1=夏天, 2=秋天, 3=冬天
            weather: 0, // 0=晴天, 1=多云, 2=雨天, 3=暴风雨
            currentSeason: "春天",
            currentWeather: "晴天",
            lastDayChange: Date.now(),
            funds: 1000,
            
            // 种植区域（4块地）
            plots: [
                { id: 0, state: 'empty', moisture: 50, fertility: 50, plantType: null, growthStage: 0, stageStartTime: 0 },
                { id: 1, state: 'empty', moisture: 50, fertility: 50, plantType: null, growthStage: 0, stageStartTime: 0 },
                { id: 2, state: 'empty', moisture: 50, fertility: 50, plantType: null, growthStage: 0, stageStartTime: 0 },
                { id: 3, state: 'empty', moisture: 50, fertility: 50, plantType: null, growthStage: 0, stageStartTime: 0 }
            ],
            
            // 炉灶（2个）
            stoves: [
                { id: 0, state: 'idle', recipe: null, startTime: 0, duration: 8000 }, // 8秒制茶
                { id: 1, state: 'idle', recipe: null, startTime: 0, duration: 8000 }  // 8秒制茶
            ],
            
            // 案板加工台（2个）
            processingBoards: [
                { id: 0, state: 'idle', recipe: null, startTime: 0, duration: 0 },
                { id: 1, state: 'idle', recipe: null, startTime: 0, duration: 0 }
            ],
            
            // 库存系统
            seeds: {}, // 种子库存
            inventory: {}, // 收获材料库存
            toppings: {}, // 小料库存
            madeTeas: [], // 制作好的茶饮
            
            // 茶饮配方
            teaRecipes: {
                '五味子饮': ['五味子'],
                '柠檬茶': ['柠檬'],
                '洛神玫瑰饮': ['洛神花', '玫瑰花', '山楂'],
                '桂圆红枣茶': ['桂圆', '红枣', '枸杞'],
                '焦香大麦茶': ['大麦'],
                '三花决明茶': ['菊花', '金银花', '决明子', '枸杞'],
                '薄荷甘草凉茶': ['薄荷', '甘草'],
                '陈皮姜米茶': ['陈皮', '生姜'],
                '冬瓜荷叶饮': ['冬瓜', '荷叶', '薏米'],
                '古法酸梅汤': ['乌梅', '山楂', '陈皮', '甘草', '桂花'],
                '小吊梨汤': ['雪花梨', '银耳', '话梅', '枸杞'],
                '白水煮鱼': ['小鱼干'] // 猫咪专用配方
            },
            
            // 加工配方
            processingRecipes: {
                // 茶饮小料加工
                '红糖': { ingredients: ['甘蔗'], time: 10000, output: 3 },
                '薄荷叶': { ingredients: ['薄荷'], time: 10000, output: 3 },
                '姜丝': { ingredients: ['生姜'], time: 10000, output: 3 },
                '柚子丝': { ingredients: ['柚子'], time: 10000, output: 3 },
                '银耳丝': { ingredients: ['银耳'], time: 15000, output: 3 },
                '柠檬片': { ingredients: ['柠檬'], time: 10000, output: 3 },
                '水蜜桃果肉': { ingredients: ['水蜜桃'], time: 12000, output: 3 },
                '黄芪片': { ingredients: ['黄芪'], time: 12000, output: 3 },
                '干桂花': { ingredients: ['桂花'], time: 10000, output: 3 },
                '小圆子': { ingredients: ['糯米'], time: 15000, output: 3 },
                '酒酿': { ingredients: ['米'], time: 18000, output: 3 },

                // 动物分解配方
                '兔子分解': {
                    ingredients: ['兔子'],
                    time: 30000,
                    outputs: [
                        { name: '兔肉', quantity: 1 },
                        { name: '兔毛', quantity: 2 },
                        { name: '兔皮', quantity: 1 }
                    ],
                    description: "将兔子分解成肉、毛、皮"
                },
                '鸡分解': {
                    ingredients: ['鸡'],
                    time: 35000,
                    outputs: [
                        { name: '鸡肉', quantity: 2 },
                        { name: '鸡毛', quantity: 3 },
                        { name: '鸡皮', quantity: 1 }
                    ],
                    description: "将鸡分解成肉、毛、皮"
                },
                '山羊分解': {
                    ingredients: ['山羊'],
                    time: 60000,
                    outputs: [
                        { name: '山羊肉', quantity: 8 },
                        { name: '山羊毛', quantity: 5 },
                        { name: '山羊皮', quantity: 2 }
                    ],
                    description: "将山羊分解成肉、毛、皮"
                },
                '野猪分解': {
                    ingredients: ['野猪'],
                    time: 90000,
                    outputs: [
                        { name: '野猪肉', quantity: 20 },
                        { name: '野猪毛', quantity: 8 },
                        { name: '野猪皮', quantity: 3 }
                    ],
                    description: "将野猪分解成肉、毛、皮"
                }
            },

            // 顾客和访客管理
            customer: {
                active: false,
                name: "等待顾客到来",
                isVIP: false,
                teaChoice: null,
                toppingChoices: [],
                arrivalTime: 0,
                patience: 120000, // 普通顾客120秒
                maxPatience: 120000,
                served: false
            },
            customerSpawnCooldown: 10000, // 10秒检查一次是否生成新顾客（便于测试）
            lastCustomerTime: 0,
            customerNames: ['池惊暮', '凌小路', '江飞飞', '江三', '江四', '池云旗', '江潮', '江敕封', '花花', '姬别情', '池九信', '狸怒'],
            customerVisits: {},
            servedCustomers: 0,

            // 猫咪系统
            cats: {
                lastCatTime: Date.now(),
                catCooldown: 259200000,   // 3天冷却时间（毫秒）
                currentCat: null,
                todayVisited: false,
                lastCatDay: 0,
                intimacy: {
                    '大橘猫': 0,
                    '狸花猫': 0,
                    '黑猫小手套': 0,
                    '小白猫': 0,
                    '大猫猫': 0
                },
                feedCount: {
                    '大橘猫': 0,
                    '狸花猫': 0,
                    '黑猫小手套': 0,
                    '小白猫': 0,
                    '大猫猫': 0
                },
                lastSeen: {},
                gifts: []
            },

            // 配方解锁规则
            recipeUnlockRules: {
                "洛神玫瑰饮": { customer: "凌小路", visitsRequired: 1, chance: 1.0, guaranteedOnVisit: 1 },
                "桂圆红枣茶": { customer: "花花", visitsRequired: 1, chance: 1.0, guaranteedOnVisit: 1 },
                "焦香大麦茶": { customer: "江飞飞", visitsRequired: 2, chance: 1.0, guaranteedOnVisit: 2 },
                "三花决明茶": { customer: "江三", visitsRequired: 2, chance: 1.0, guaranteedOnVisit: 2 },
                "薄荷甘草凉茶": { customer: "江四", visitsRequired: 2, chance: 1.0, guaranteedOnVisit: 2 },
                "陈皮姜米茶": { customer: "池云旗", visitsRequired: 2, chance: 0.5, guaranteedOnVisit: 3 },
                "冬瓜荷叶饮": { customer: "江潮", visitsRequired: 3, chance: 0.6, guaranteedOnVisit: 4 },
                "古法酸梅汤": { customer: "池惊暮", visitsRequired: 2, chance: 0.3, guaranteedOnVisit: 3 },
                "小吊梨汤": { customer: "江敕封", visitsRequired: 3, chance: 0.4, guaranteedOnVisit: 5 },
                // 神秘顾客配方
                "高级茶饮": { customer: "姬别情", visitsRequired: 3, chance: 0.8, guaranteedOnVisit: 4 },
                "特制茶饮": { customer: "池九信", visitsRequired: 2, chance: 0.7, guaranteedOnVisit: 3 },
                "动物茶饮": { customer: "狸怒", visitsRequired: 1, chance: 1.0, guaranteedOnVisit: 1 },
            },

            // 顾客故事系统
            customerStories: {
                "凌小路": {
                    title: "《朱砂》",
                    content: "凌小路袖中藏着一盏温热的洛神玫瑰饮。'疏肝解郁的，好好学学，飞飞来了就做给他。跟他说就说养颜的茶方子'挑眉笑时，眼底却映着刀光，袍角还沾着血。",
                    effect: "疏肝解郁，美白养颜，活血调经，适合女子日常饮用。",
                    character: "神秘的女刺客，外表温和内心危险，对江飞飞有特殊感情"
                },
                "花花": {
                    title: "《无归》",
                    content: "花花去凌雪坟前扫墓，手里拿着他最喜欢她给他做的茶。只是这一次只能自己做了。'自己给自己作茶怎么行，这方子给你们，以后我就来这里喝吧'",
                    effect: "补血益气，安神养心，滋阴润燥，适合体弱或熬夜者饮用。",
                    character: "温柔的女子，失去了爱人凌雪，独自承受痛苦"
                },
                "江飞飞": {
                    title: "《雪夜》",
                    content: "长安冬夜，江飞飞蜷在凌雪阁的屋檐上，指尖冻得发僵。江三翻上屋顶，扔来一壶滚烫的大麦茶：'怂样，喝两口。'茶雾氤氲里，他忽然想起幼时第一次握刀，也是这焦苦的甜香压住了颤抖。",
                    effect: "暖胃消食，缓解焦虑，安定心神，适合秋冬饮用。",
                    character: "年轻的刺客，容易紧张，和江三有兄弟情义"
                },
                "江三": {
                    title: "《夜狩》",
                    content: "江四执刀归来，见江三伏案瞌睡，手边一盏凉透的三花决明茶。他轻叹，将外袍披上兄长肩头——却不知昨夜自己任务单上那三个名字，早已被江三的血刃划去。茶渣沉底，如未愈的旧伤。",
                    effect: "清肝明目，清热解毒，缓解眼疲劳，适合长期伏案或夜视者饮用。",
                    character: "江四的兄长，默默保护弟弟，承担更多危险任务"
                },
                "江四": {
                    title: "《三哥》",
                    content: "江四给江三泡的茶，清清凉凉的，他那么爱出汗，肯定喜欢。茶叶刚放下，就听到三哥在院子里训练的刀声，他悄悄探头看了一眼，决定加多一片薄荷叶。",
                    effect: "清热解暑，润喉止咳，提神醒脑，适合夏季饮用。",
                    character: "江三的弟弟，细心体贴，关心兄长的身体"
                },
                "池云旗": {
                    title: "《师徒》",
                    content: "池云旗心疼那小家伙，以前也不懂自己照顾自己，这茶是她专门给他找医师抄的方子。'别总吃那些乱七八糟的东西，胃疼了可别来找师父'虽然嘴上这么说，她还是悄悄在茶里多加了一片陈皮。",
                    effect: "健脾和胃，理气化痰，温中散寒，适合消化不良或胃寒者饮用。",
                    character: "江潮的师父，表面严厉内心慈祥，关心徒弟的健康"
                },
                "江潮": {
                    title: "《师徒2》",
                    content: "江潮给师父弄的消暑茶，荷叶是自己趴在池塘边采的，冬瓜也是自己种的。'师父，您尝尝，我按照您说的方法做的'他小心翼翼地端着茶，生怕师父不喜欢，却不知道池云旗早已欣慰地笑了。",
                    effect: "清热利湿，消肿减脂，美容养颜，适合夏季消暑或减肥者饮用。",
                    character: "池云旗的徒弟，努力上进，孝顺师父"
                },
                "池惊暮": {
                    title: "《梅香》",
                    content: "长安暑夜，池惊暮执剑伏于屋脊。目标出现时，她正饮尽最后一滴酸梅汤。瓷碗坠地碎响混着喉骨断裂声，梅妃教的小方子——杀人时唇齿间该留着甜味，才不苦。",
                    effect: "生津止渴，消暑解腻，健脾开胃，缓解燥热，唐代已是宫廷消暑佳饮。",
                    character: "冷血杀手，出身宫廷，有着优雅的杀戮美学"
                },
                "江敕封": {
                    title: "《琴心》",
                    content: "江敕封抚琴时总爱在身边放一盏小吊梨汤，琴声悠扬，茶香袅袅。他说琴如人生，需要慢慢调教；茶如心境，需要细细品味。一曲终了，一盏茶尽，都是这世间最温柔的时光。",
                    effect: "润肺止咳，清热降火，滋阴美容，宫廷传统滋补佳品。",
                    character: "文雅的琴师，热爱音乐，追求精神境界"
                },
                // 神秘顾客没有详细故事，只有基本人物特征
                // 根据README.md设定，神秘顾客保持神秘感，不展示完整故事
            },

            // 人数解锁配方系统
            customerCountUnlockRules: {
                "桑菊润燥茶": { customersRequired: 30, ingredients: ['桑叶', '杭白菊'] },
                "桂花酒酿饮": { customersRequired: 60, ingredients: ['桂花', '酒酿'] },
                "蜜桃乌龙冷萃": { customersRequired: 90, ingredients: ['水蜜桃', '乌龙茶包'] },
                "黄芪枸杞茶": { customersRequired: 120, ingredients: ['黄芪', '枸杞'] },
                "竹蔗茅根马蹄水": { customersRequired: 150, ingredients: ['甘蔗', '白茅根', '马蹄'] }
            },

            // 烤肉架系统
            grillSystem: {
                unlocked: false,
                isGrilling: false,
                grillStartTime: 0,
                grillDuration: 0,
                currentRecipe: null,
                currentProduct: null,
                recipes: {
                    "烤兔肉": {
                        ingredients: ['兔肉'],
                        cookTime: 30000,
                        price: 25,
                        description: "香嫩的烤兔肉"
                    },
                    "烤鸡肉": {
                        ingredients: ['鸡肉'],
                        cookTime: 35000,
                        price: 30,
                        description: "美味的烤鸡肉"
                    },
                    "烤山羊肉": {
                        ingredients: ['山羊肉'],
                        cookTime: 45000,
                        price: 50,
                        description: "鲜美的烤山羊肉"
                    },
                    "烤野猪肉": {
                        ingredients: ['野猪肉'],
                        cookTime: 60000,
                        price: 80,
                        description: "浓郁的烤野猪肉"
                    }
                },
                sellOptions: {
                    "直接售卖": {
                        description: "立即获得金币",
                        priceMultiplier: 1.0
                    },
                    "服务顾客": {
                        description: "等待顾客点餐",
                        priceMultiplier: 1.2
                    }
                }
            },

            // 打猎系统
            huntingSystem: {
                // 后山打猎
                backMountain: {
                    unlocked: false,
                    huntCount: 0,
                    isHunting: false,
                    huntStartTime: 0,
                    huntDuration: 15000, // 15秒
                    huntResults: {
                        // 基础猎物 (0-49次)
                        basic: [
                            { name: '兔子', chance: 0.25, firstTimeRecipe: null },
                            { name: '浆果', chance: 0.2, firstTimeRecipe: '浆果汁' },
                            { name: '小鱼干', chance: 0.2, firstTimeRecipe: null },
                            { name: '鸡', chance: 0.2, firstTimeRecipe: null },
                            { name: '簪子', chance: 0.03, firstTimeRecipe: null },
                            { name: '梳子', chance: 0.03, firstTimeRecipe: null },
                            { name: '石头', chance: 0.05, firstTimeRecipe: null },
                            { name: '花朵', chance: 0.04, firstTimeRecipe: null },
                            { name: '金币', chance: 0.06, firstTimeRecipe: null, value: 15 },
                            { name: '地图', chance: 0.05, firstTimeRecipe: null, special: 'unlock_cave' }
                        ],
                        // 高级猎物 (50次后)
                        advanced: [
                            { name: '山羊', chance: 0.08, firstTimeRecipe: null },
                            { name: '野猪', chance: 0.04, firstTimeRecipe: null },
                            { name: '野葱', chance: 0.08, firstTimeRecipe: null },
                            { name: '山姜', chance: 0.08, firstTimeRecipe: null },
                            { name: '香菜', chance: 0.08, firstTimeRecipe: null }
                        ]
                    }
                },
                // 山洞打猎
                cave: {
                    unlocked: false,
                    huntCount: 0,
                    isHunting: false,
                    huntStartTime: 0,
                    huntDuration: 20000, // 20秒
                    huntResults: {
                        // 基础猎物
                        basic: [
                            { name: '兔子', chance: 0.25, firstTimeRecipe: null },
                            { name: '浆果', chance: 0.18, firstTimeRecipe: null },
                            { name: '小鱼干', chance: 0.18, firstTimeRecipe: null },
                            { name: '鸡', chance: 0.2, firstTimeRecipe: null },
                            { name: '银耳', chance: 0.15, firstTimeRecipe: null }, // 山洞特有
                            { name: '簪子', chance: 0.04, firstTimeRecipe: null },
                            { name: '梳子', chance: 0.04, firstTimeRecipe: null },
                            { name: '石头', chance: 0.06, firstTimeRecipe: null },
                            { name: '花朵', chance: 0.03, firstTimeRecipe: null },
                            { name: '金币', chance: 0.08, firstTimeRecipe: null, value: 20 }
                        ],
                        // 高级猎物 (50次后)
                        advanced: [
                            { name: '山羊', chance: 0.08, firstTimeRecipe: null },
                            { name: '野猪', chance: 0.04, firstTimeRecipe: null },
                            { name: '野葱', chance: 0.08, firstTimeRecipe: null },
                            { name: '山姜', chance: 0.08, firstTimeRecipe: null },
                            { name: '香菜', chance: 0.08, firstTimeRecipe: null }
                        ]
                    }
                }
            }
        };

        // 小料商店配置
        const toppingsShop = {
            "冰糖": { price: 3, description: "制作甜茶的好选择" },
            "蜂蜜": { price: 5, description: "天然甜味剂，营养丰富" },
            "乌龙茶包": { price: 8, description: "高级茶包，提升茶饮品质" },
            "小鱼干": { price: 6, description: "猫咪最爱的零食" },
            "猫薄荷": { price: 10, description: "猫咪的神奇草药" },
            "干桂花": { price: 4, description: "增加花香的小料" },
            "小圆子": { price: 3, description: "Q弹软糯的小配菜" },
            "酒酿": { price: 6, description: "传统发酵小料" },
            "话梅": { price: 4, description: "酸甜解腻的果脯" },
            "陈皮丝": { price: 5, description: "理气化痰的中药材" },
            "桂圆肉": { price: 7, description: "补血安神的滋补品" },
            "莲子": { price: 6, description: "清心安神的天然食材" }
        };

        // 动物副产品售卖配置
        const animalByproducts = {
            "兔毛": { price: 5, description: "柔软的兔毛，可以售卖" },
            "兔皮": { price: 8, description: "优质兔皮，可以售卖" },
            "鸡毛": { price: 3, description: "轻盈的鸡毛，可以售卖" },
            "鸡皮": { price: 6, description: "鸡皮，可以售卖" },
            "山羊毛": { price: 12, description: "温暖的山羊毛，可以售卖" },
            "山羊皮": { price: 25, description: "厚实的山羊皮，可以售卖" },
            "野猪毛": { price: 8, description: "粗糙的野猪毛，可以售卖" },
            "野猪皮": { price: 40, description: "坚韧的野猪皮，可以售卖" }
        };

        // 云端存储配置
        const cloudSaveConfig = {
            githubToken: localStorage.getItem('githubToken') || '',
            gistId: localStorage.getItem('gistId') || '',
            autoSyncInterval: 5 * 60 * 1000, // 5分钟自动同步
            lastSyncTime: 0,
            isOnline: navigator.onLine,
            syncInProgress: false
        };

        // 种子信息配置 - 缩短生长时间以便快速体验游戏
        const seedsInfo = {
            "五味子": { price: 1, growTime: 10000 }, "乌梅": { price: 1, growTime: 10000 },
            "山楂": { price: 1, growTime: 10000 }, "陈皮": { price: 1, growTime: 10000 },
            "甘草": { price: 1, growTime: 10000 }, "桂花": { price: 1, growTime: 10000 },
            "大麦": { price: 1, growTime: 10000 }, "菊花": { price: 1, growTime: 10000 },
            "金银花": { price: 1, growTime: 10000 }, "决明子": { price: 1, growTime: 10000 },
            "枸杞": { price: 1, growTime: 10000 }, "生姜": { price: 1, growTime: 10000 },
            "桂圆": { price: 1, growTime: 10000 }, "红枣": { price: 1, growTime: 10000 },
            "薄荷": { price: 1, growTime: 10000 }, "玫瑰花": { price: 1, growTime: 10000 },
            "洛神花": { price: 1, growTime: 10000 }, "冬瓜": { price: 1, growTime: 10000 },
            "荷叶": { price: 1, growTime: 10000 }, "薏米": { price: 1, growTime: 10000 },
            "雪花梨": { price: 1, growTime: 10000 }, "话梅": { price: 1, growTime: 10000 },
            "甘蔗": { price: 1, growTime: 10000 }, "柚子": { price: 1, growTime: 10000 },
            "柠檬": { price: 1, growTime: 10000 }, "银耳": { price: 1, growTime: 10000 },
            "桑叶": { price: 2, growTime: 15000 }, "杭白菊": { price: 2, growTime: 15000 },
            "水蜜桃": { price: 3, growTime: 20000 }, "黄芪": { price: 3, growTime: 20000 },
            "白茅根": { price: 2, growTime: 15000 }, "马蹄": { price: 2, growTime: 15000 },
            "糯米": { price: 2, growTime: 15000 }, "米": { price: 1, growTime: 15000 }
        };

        // 初始化数据
        function initializeData() {
            // 初始化种子和材料库存 - 提供更多初始材料以便快速开始游戏
            Object.keys(seedsInfo).forEach(material => {
                gameData.seeds[material] = material === "五味子" || material === "柠檬" ? 3 : 0;
                // 给予一些初始材料，特别是基础配方材料
                if (material === "五味子" || material === "柠檬") {
                    gameData.inventory[material] = 5;
                } else {
                    gameData.inventory[material] = gameData.inventory[material] || 0;
                }
            });

            // 初始化小料库存 - 包含基础小料和商店可购买的小料
            gameData.toppings = {
                "红糖": 5, "薄荷叶": 5, "姜丝": 5, "柚子丝": 5,
                "银耳丝": 5, "柠檬片": 5, "蜂蜜": 3,
                "冰糖": 0, "乌龙茶包": 0, "干桂花": 0,
                "小圆子": 0, "酒酿": 0, "水蜜桃果肉": 0, "黄芪片": 0,
                // 商店可购买的小料 - 初始化为0
                "小鱼干": 0, "猫薄荷": 0, "话梅": 0, "陈皮丝": 0,
                "桂圆肉": 0, "莲子": 0
            };

            // 确保天气数据同步
            gameData.currentWeather = weathers[gameData.weather] || "晴天";
            gameData.currentSeason = seasons[gameData.season] || "春天";

            // 初始化顾客访问记录
            if (!gameData.customerVisits) {
                gameData.customerVisits = {};
                gameData.customerNames.forEach(name => {
                    gameData.customerVisits[name] = 0;
                });
            }

            // 同步customerVisits和customers.visits数据
            if (gameData.customers && gameData.customerVisits) {
                Object.keys(gameData.customers).forEach(name => {
                    if (gameData.customerVisits[name] !== undefined) {
                        gameData.customers[name].visits = gameData.customerVisits[name];
                    } else {
                        gameData.customerVisits[name] = gameData.customers[name].visits || 0;
                    }
                });
            }

            // 初始化顾客系统数据 - 保留已有的访问次数
            if (!gameData.customers) {
                gameData.customers = {};
            }

            // 定义默认顾客数据
            const defaultCustomers = {
                '池惊暮': { avatar: '🧙‍♂️', visits: 0, requiredVisits: 2, unlockedRecipe: '古法酸梅汤' },
                '凌小路': { avatar: '👩‍🎓', visits: 0, requiredVisits: 1, unlockedRecipe: '洛神玫瑰饮' },
                '江飞飞': { avatar: '👨‍💼', visits: 0, requiredVisits: 2, unlockedRecipe: '焦香大麦茶' },
                '江三': { avatar: '👨‍🔧', visits: 0, requiredVisits: 2, unlockedRecipe: '三花决明茶' },
                '江四': { avatar: '👩‍🍳', visits: 0, requiredVisits: 2, unlockedRecipe: '薄荷甘草凉茶' },
                '池云旗': { avatar: '👴', visits: 0, requiredVisits: 3, unlockedRecipe: '陈皮姜米茶' },
                '江潮': { avatar: '👨‍🎨', visits: 0, requiredVisits: 4, unlockedRecipe: '冬瓜荷叶饮' },
                '江敕封': { avatar: '🧓', visits: 0, requiredVisits: 5, unlockedRecipe: '小吊梨汤' },
                '花花': { avatar: '👧', visits: 0, requiredVisits: 1, unlockedRecipe: '桂圆红枣茶' },
                '姬别情': { avatar: '👩‍💻', visits: 0, requiredVisits: 6, unlockedFeature: '烤肉架' },
                '池九信': { avatar: '👨‍🏫', visits: 0, requiredVisits: 2, unlockedRecipe: '特制茶饮' },
                '狸怒': { avatar: '🦝', visits: 0, requiredVisits: 1, unlockedRecipe: '动物茶饮' }
            };

            // 合并默认数据和已有数据，保留已有的访问次数
            Object.keys(defaultCustomers).forEach(name => {
                if (!gameData.customers[name]) {
                    gameData.customers[name] = { ...defaultCustomers[name] };
                } else {
                    // 保留已有的visits，更新其他属性
                    const existingVisits = gameData.customers[name].visits || 0;
                    gameData.customers[name] = {
                        ...defaultCustomers[name],
                        visits: existingVisits
                    };
                }
            });

            // 初始化猫咪系统数据 - 修复版本
            if (!gameData.cats) {
                gameData.cats = {};
            }
            
            // 确保每只猫咪的数据结构完整
            const catList = ['大橘猫', '狸花猫', '黑猫小手套', '小白猫', '大猫猫'];
            const avatars = ['🧡', '🐱', '🖤', '🤍', '😺'];
            
            catList.forEach((catName, index) => {
                if (!gameData.cats[catName]) {
                    gameData.cats[catName] = {
                        avatar: avatars[index],
                        intimacy: 0,
                        lastGift: null,
                        gifts: ['金币', '种子', '金币', '种子'] // 可能的礼物
                    };
                }
                // 确保旧数据兼容性
                if (typeof gameData.cats[catName].intimacy === 'undefined') {
                    gameData.cats[catName].intimacy = 0;
                }
                if (!gameData.cats[catName].gifts) {
                    gameData.cats[catName].gifts = ['金币', '种子', '金币', '种子'];
                }
            });

            // 保持旧的 intimacy 结构用于兼容
            if (!gameData.cats.intimacy) {
                gameData.cats.intimacy = {};
                catList.forEach(catName => {
                    gameData.cats.intimacy[catName] = gameData.cats[catName].intimacy || 0;
                });
            }

            // 初始化游戏天数和顾客系统
            if (!gameData.currentDay) {
                gameData.currentDay = 1;
            }

            // 重置顾客生成时间，确保立即可以生成顾客
            gameData.lastCustomerTime = 0;

            // 初始化顾客和猫咪状态显示（延迟执行，确保DOM元素已就绪）
            setTimeout(() => {
                if (typeof updateCustomerDisplay === 'function') {
                    updateCustomerDisplay();
                }
            }, 100);
            
            addDebugLog('游戏数据初始化完成 - 已提供初始材料');
        }

        // 渲染种植区域
        function renderFarmGrid() {
            const farmGrid = document.getElementById('farm-grid');
            farmGrid.innerHTML = '';

            gameData.plots.forEach((plot, index) => {
                const plotCard = document.createElement('div');
                plotCard.className = 'plot-card';
                
                const statusClass = plot.state === 'empty' ? 'status-empty' : 
                                  plot.state === 'growing' ? 'status-growing' : 'status-ready';
                
                // 计算生长状态和倒计时
                let statusText = plot.state === 'empty' ? '空闲' : 
                               plot.state === 'ready' ? '可收获' : '生长中';
                
                if (plot.state === 'growing' && plot.plantType && plot.plantTime) {
                    const growTime = seedsInfo[plot.plantType].growTime;
                    const elapsed = Date.now() - plot.plantTime;
                    const remaining = Math.max(0, growTime - elapsed);
                    
                    if (remaining > 0) {
                        const remainingSeconds = Math.ceil(remaining / 1000);
                        const progress = Math.round((elapsed / growTime) * 100);
                        statusText = `生长中 (${remainingSeconds}秒) ${progress}%`;
                    } else {
                        statusText = '可收获';
                        // 如果时间到了但状态还没更新，强制更新状态
                        if (plot.state === 'growing') {
                            plot.state = 'ready';
                        }
                    }
                }

                plotCard.innerHTML = `
                    <div class="plot-header">
                        <div class="plot-title">种植区域 ${index + 1}</div>
                        <div class="plot-status ${statusClass}">${statusText}</div>
                    </div>
                    
                    <table class="conditions-table">
                        <tr>
                            <td style="width: 80px; font-weight: 600;">湿度</td>
                            <td>
                                <div class="progress-bar">
                                    <div class="plot-progress-container">
                            <div class="plot-progress-bar moisture-progress" style="width: ${plot.moisture}%"></div>
                            <div class="plot-progress-text">${plot.moisture}%</div>
                        </div>
                                </div>
                            </td>
                            <td style="width: 50px; text-align: center; font-weight: 600;">${plot.moisture}%</td>
                        </tr>
                        <tr>
                            <td style="font-weight: 600;">肥沃度</td>
                            <td>
                                <div class="progress-bar">
                                    <div class="plot-progress-container">
                            <div class="plot-progress-bar fertility-progress" style="width: ${plot.fertility}%"></div>
                            <div class="plot-progress-text">${plot.fertility}%</div>
                        </div>
                                </div>
                            </td>
                            <td style="text-align: center; font-weight: 600;">${plot.fertility}%</td>
                        </tr>
                        ${plot.plantType ? `<tr><td style="font-weight: 600;">种植作物</td><td colspan="2">${plot.plantType}</td></tr>` : ''}
                        ${plot.state === 'growing' && plot.plantType && plot.plantTime ? 
                            `<tr>
                                <td style="font-weight: 600;">生长进度</td>
                                <td>
                                    <div class="progress-bar">
                                        <div class="plot-progress-container">
                            <div class="plot-progress-bar growth-progress" style="width: ${Math.round((Date.now() - plot.plantTime) / seedsInfo[plot.plantType].growTime * 100)}%"></div>
                            <div class="plot-progress-text">${Math.round((Date.now() - plot.plantTime) / seedsInfo[plot.plantType].growTime * 100)}%</div>
                        </div>
                                    </div>
                                </td>
                                <td style="text-align: center; font-weight: 600;">${Math.round((Date.now() - plot.plantTime) / seedsInfo[plot.plantType].growTime * 100)}%</td>
                            </tr>` : ''}
                    </table>
                    
                    <div class="plot-actions">
                        <button class="action-btn" onclick="waterPlot(${index})">浇水</button>
                        <button class="action-btn" onclick="fertilizePlot(${index})">施肥</button>
                        ${plot.state === 'empty' ? `<button class="action-btn primary" onclick="showSeedModal(${index})">种植</button>` : ''}
                        ${plot.state === 'ready' ? `<button class="action-btn primary" onclick="harvestPlot(${index})">收获</button>` : ''}
                    </div>
                `;
                
                farmGrid.appendChild(plotCard);
            });
        }

        // 渲染其他区域
        function renderWorkspaces() {
            renderStoves();
            renderProcessingBoard();
            renderCatsTable();
            updateAllInventoryDisplay();
        }

        function renderStoves() {
            const stovesTable = document.getElementById('stoves-table');
            stovesTable.innerHTML = '';

            gameData.stoves.forEach((stove, index) => {
                const row = document.createElement('tr');
                const recipeText = stove.recipe || '等待制作';
                
                // 制作进度条
                let progressHTML = '';
                if (stove.state === 'cooking') {
                    const progressPercent = Math.round((Date.now() - stove.startTime) / stove.duration * 100);
                    const clampedProgress = Math.min(Math.max(progressPercent, 0), 100);
                    progressHTML = `
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: ${clampedProgress}%; background: #e5e7eb;"></div>
                            <div class="progress-text">${clampedProgress}%</div>
                        </div>
                    `;
                } else {
                    progressHTML = `
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: 0%; background: #e5e7eb;"></div>
                            <div class="progress-text">未开始</div>
                        </div>
                    `;
                }

                row.innerHTML = `
                    <td>炉灶 ${index + 1}</td>
                    <td>${recipeText}</td>
                    <td>${progressHTML}</td>
                    <td>
                        ${stove.state === 'idle' ? 
                            `<button class="action-btn primary" onclick="showRecipeModal(${index})">开始制茶</button>` : 
                            `<button class="action-btn" disabled>制作中...</button>`
                        }
                    </td>
                `;
                stovesTable.appendChild(row);
            });
        }

        function renderProcessingBoard() {
            const processingTable = document.getElementById('processing-table');
            processingTable.innerHTML = '';

            gameData.processingBoards.forEach((board, index) => {
                const row = document.createElement('tr');
                const recipeText = board.recipe || '等待加工';
                
                // 加工进度条
                let progressHTML = '';
                if (board.state === 'processing') {
                    const progressPercent = Math.round((Date.now() - board.startTime) / board.duration * 100);
                    const clampedProgress = Math.min(Math.max(progressPercent, 0), 100);
                    progressHTML = `
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: ${clampedProgress}%; background: #e5e7eb;"></div>
                            <div class="progress-text">${clampedProgress}%</div>
                        </div>
                    `;
                } else {
                    progressHTML = `
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: 0%; background: #e5e7eb;"></div>
                            <div class="progress-text">未开始</div>
                        </div>
                    `;
                }

                row.innerHTML = `
                    <td>案板 ${index + 1}</td>
                    <td>${recipeText}</td>
                    <td>${progressHTML}</td>
                    <td>
                        ${board.state === 'idle' ? 
                            `<button class="action-btn primary" onclick="showProcessingModal(${index})">开始加工</button>` : 
                            `<button class="action-btn" disabled>加工中...</button>`
                        }
                    </td>
                `;
                processingTable.appendChild(row);
            });
        }

        function renderInventories() {
            renderTeaInventory();
            renderToppingsInventory();
            renderMaterialsInventory();
            renderCustomersTable();
            renderCatsTable();
        }

        function renderTeaInventory() {
            const teaInventory = document.getElementById('tea-inventory');
            teaInventory.innerHTML = '';

            if (gameData.madeTeas.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="5">暂无制作好的茶饮</td>';
                teaInventory.appendChild(row);
                return;
            }

            gameData.madeTeas.forEach((tea, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${tea.name}</td>
                    <td>${tea.temperature || '常温'}</td>
                    <td>${tea.makeTime || '-'}</td>
                    <td>1</td>
                    <td><button class="action-btn" onclick="serveTea(${index})">售出</button></td>
                `;
                teaInventory.appendChild(row);
            });
        }

        // 顾客系统渲染函数
        function renderCustomersTable() {
            const customersTable = document.getElementById('customers-table');
            if (!customersTable) return;
            
            customersTable.innerHTML = '';

            // 安全检查：确保customers已初始化
            if (!gameData.customers) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="4">顾客系统初始化中...</td>';
                customersTable.appendChild(row);
                return;
            }

            Object.entries(gameData.customers).forEach(([name, customerData]) => {
                const row = document.createElement('tr');
                const isUnlocked = customerData.visits >= customerData.requiredVisits;
                const progress = `${customerData.visits}/${customerData.requiredVisits}`;
                
                row.innerHTML = `
                    <td>
                        <span class="customer-avatar">${customerData.avatar}</span>
                        ${name}
                    </td>
                    <td>${progress}</td>
                    <td style="${isUnlocked ? 'color: #6b7280; font-weight: 600;' : 'color: #6b7280;'}">
                        ${isUnlocked ? '✓ ' : '🔒 '}${customerData.unlockedRecipe}
                    </td>
                    <td>
                        <button class="action-btn" onclick="showCustomerStory('${name}')"
                                style="margin-right: 5px;">
                            📖 故事
                        </button>
                        <button class="action-btn" onclick="inviteCustomer('${name}')"
                                ${customerData.visits >= customerData.requiredVisits ? 'disabled' : ''}>
                            ${customerData.visits >= customerData.requiredVisits ? '已完成' : '邀请来访'}
                        </button>
                    </td>
                `;
                customersTable.appendChild(row);
            });
        }

        // 猫咪系统渲染函数
        function renderCatsTable() {
            const catsTable = document.getElementById('cats-table');
            if (!catsTable) return;
            
            catsTable.innerHTML = '';

            // 安全检查：确保cats已初始化
            if (!gameData.cats) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="5">猫咪系统初始化中...</td>';
                catsTable.appendChild(row);
                return;
            }

            // 遍历猫咪数据，过滤掉非猫咪属性
            const catNames = ['大橘猫', '狸花猫', '黑猫小手套', '小白猫', '大猫猫'];
            
            catNames.forEach(name => {
                // 确保每只猫咪都有数据，即使是初始状态
                if (!gameData.cats[name]) {
                    gameData.cats[name] = {
                        avatar: ['🧡', '🐱', '🖤', '🤍', '😺'][catNames.indexOf(name)],
                        intimacy: 0,
                        lastGift: null,
                        gifts: ['金币', '种子', '金币', '种子']
                    };
                }

                const catData = gameData.cats[name];
                const row = document.createElement('tr');

                // 根据README.md设定的里程碑：500/1500/3000/5000
                let intimacyLevel = 1;
                let levelName = '陌生';
                if (catData.intimacy >= 5000) {
                    intimacyLevel = 5;
                    levelName = '挚友';
                } else if (catData.intimacy >= 3000) {
                    intimacyLevel = 4;
                    levelName = '亲密';
                } else if (catData.intimacy >= 1500) {
                    intimacyLevel = 3;
                    levelName = '友好';
                } else if (catData.intimacy >= 500) {
                    intimacyLevel = 2;
                    levelName = '熟悉';
                }

                row.innerHTML = `
                    <td>${name}</td>
                    <td>
                        <div class="intimacy-bar">
                            <div class="intimacy-progress" style="width: ${Math.min(100, (catData.intimacy / 5000) * 100)}%"></div>
                        </div>
                        ${catData.intimacy}/5000
                    </td>
                    <td>${levelName} (Lv.${intimacyLevel})</td>
                    <td>${catData.lastGift || '暂无'}</td>
                    <td>
                        <button class="action-btn" onclick="selectCatForInteraction('${name}')">选择互动</button>
                    </td>
                `;
                catsTable.appendChild(row);
            });
        }

        function renderToppingsInventory() {
            const toppingsInventory = document.getElementById('toppings-inventory');
            toppingsInventory.innerHTML = '';

            // 显示toppings中的小料
            Object.entries(gameData.toppings).forEach(([name, count]) => {
                if (count > 0) {
                    const row = document.createElement('tr');

                    // 判断获取方式
                    let getMethod = '案板加工';
                    let actionButton = '-';

                    // 检查是否是商店可购买的小料
                    if (toppingsShop[name]) {
                        getMethod = `商店购买 (${toppingsShop[name].price}金币)`;
                        const canAfford = gameData.funds >= toppingsShop[name].price;
                        actionButton = `<button class="action-btn" onclick="buyTopping('${name}')" ${canAfford ? '' : 'disabled'}>
                            ${canAfford ? '购买' : '资金不足'}
                        </button>`;
                    } else if (name.includes('红糖') || name.includes('薄荷叶') || name.includes('姜丝') ||
                        name.includes('柚子丝') || name.includes('银耳丝') || name.includes('柠檬片') || name.includes('蜂蜜')) {
                        getMethod = '初始拥有';
                        actionButton = `<button class="action-btn">使用</button>`;
                    } else {
                        // 案板加工的小料
                        actionButton = `<button class="action-btn">使用</button>`;
                    }

                    row.innerHTML = `
                        <td>${name}</td>
                        <td>${count}</td>
                        <td>${getMethod}</td>
                        <td>${actionButton}</td>
                    `;
                    toppingsInventory.appendChild(row);
                }
            });

            // 显示动物副产品（从materials中）
            if (gameData.materials) {
                const byproductItems = Object.entries(gameData.materials).filter(([name, count]) =>
                    animalByproducts[name] && count > 0
                );

                if (byproductItems.length > 0) {
                    // 添加分隔行
                    const separatorRow = document.createElement('tr');
                    separatorRow.innerHTML = `
                        <td colspan="4" style="background-color: #fef3c7; text-align: center; font-weight: bold; color: #92400e;">
                            🐾 动物副产品（可售卖）
                        </td>
                    `;
                    toppingsInventory.appendChild(separatorRow);

                    // 显示副产品
                    byproductItems.forEach(([name, count]) => {
                        const byproduct = animalByproducts[name];
                        const row = document.createElement('tr');

                        row.innerHTML = `
                            <td>${name}</td>
                            <td style="background-color: #fef3c7; font-weight: 600;">${count}</td>
                            <td>动物分解获得</td>
                            <td>
                                <button class="action-btn" onclick="sellByproduct('${name}')" style="background-color: #22c55e; color: white;">
                                    售卖 (${byproduct.price}金币)
                                </button>
                            </td>
                        `;
                        toppingsInventory.appendChild(row);
                    });
                }
            }
        }

        function renderMaterialsInventory() {
            const materialsInventory = document.getElementById('materials-inventory');
            materialsInventory.innerHTML = '';

            // 显示种植类材料
            Object.keys(seedsInfo).forEach(material => {
                const row = document.createElement('tr');
                const seedCount = gameData.seeds[material] || 0;
                const materialCount = gameData.inventory[material] || 0;
                const price = seedsInfo[material].price;
                const growTime = Math.round(seedsInfo[material].growTime / 1000);

                // 如果有收获的材料，突出显示
                const materialStyle = materialCount > 0 ? 'style="background-color: #e8f5e8; font-weight: 600;"' : '';

                row.innerHTML = `
                    <td>${material}</td>
                    <td>${seedCount}</td>
                    <td ${materialStyle}>${materialCount}${materialCount > 0 ? ' ✓' : ''}</td>
                    <td>${price} 金币</td>
                    <td>${growTime} 秒</td>
                    <td>
                        ${seedCount === 0 ?
                            `<button class="action-btn" onclick="buySeed('${material}')">购买种子</button>` :
                            `<button class="action-btn" onclick="plantSeedFromInventory('${material}')">种植</button>`
                        }
                    </td>
                `;
                materialsInventory.appendChild(row);
            });

            // 显示打猎获得的材料（分类显示）
            if (gameData.materials && Object.keys(gameData.materials).length > 0) {
                // 分类材料
                const animals = ['兔子', '鸡', '山羊', '野猪'];
                const meats = ['兔肉', '鸡肉', '山羊肉', '野猪肉'];
                const others = Object.keys(gameData.materials).filter(item =>
                    !animals.includes(item) && !meats.includes(item) && gameData.materials[item] > 0
                );

                // 显示完整动物
                const availableAnimals = animals.filter(animal => gameData.materials[animal] > 0);
                if (availableAnimals.length > 0) {
                    const separatorRow = document.createElement('tr');
                    separatorRow.innerHTML = `
                        <td colspan="6" style="background-color: #fef3c7; text-align: center; font-weight: bold; color: #92400e;">
                            🐰 完整动物（需要分解）
                        </td>
                    `;
                    materialsInventory.appendChild(separatorRow);

                    availableAnimals.forEach(animal => {
                        const count = gameData.materials[animal];
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${animal}</td>
                            <td>-</td>
                            <td style="background-color: #fef3c7; font-weight: 600;">${count} ✓</td>
                            <td>打猎获得</td>
                            <td>-</td>
                            <td>
                                <span style="color: #92400e; font-size: 12px;">前往加工台分解</span>
                            </td>
                        `;
                        materialsInventory.appendChild(row);
                    });
                }

                // 显示肉类材料
                const availableMeats = meats.filter(meat => gameData.materials[meat] > 0);
                if (availableMeats.length > 0) {
                    const separatorRow = document.createElement('tr');
                    separatorRow.innerHTML = `
                        <td colspan="6" style="background-color: #fee2e2; text-align: center; font-weight: bold; color: #991b1b;">
                            🥩 肉类材料（可烤制）
                        </td>
                    `;
                    materialsInventory.appendChild(separatorRow);

                    availableMeats.forEach(meat => {
                        const count = gameData.materials[meat];
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${meat}</td>
                            <td>-</td>
                            <td style="background-color: #fee2e2; font-weight: 600;">${count} ✓</td>
                            <td>分解获得</td>
                            <td>-</td>
                            <td>
                                <span style="color: #991b1b; font-size: 12px;">前往烤肉架烤制</span>
                            </td>
                        `;
                        materialsInventory.appendChild(row);
                    });
                }

                // 显示其他打猎材料
                if (others.length > 0) {
                    const separatorRow = document.createElement('tr');
                    separatorRow.innerHTML = `
                        <td colspan="6" style="background-color: #f0f9ff; text-align: center; font-weight: bold; color: #1e40af;">
                            🐟 其他打猎材料
                        </td>
                    `;
                    materialsInventory.appendChild(separatorRow);

                    others.forEach(material => {
                        const count = gameData.materials[material];
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${material}</td>
                            <td>-</td>
                            <td style="background-color: #f0f9ff; font-weight: 600;">${count} ✓</td>
                            <td>打猎获得</td>
                            <td>-</td>
                            <td>
                                <span style="color: #1e40af; font-size: 12px;">打猎材料</span>
                            </td>
                        `;
                        materialsInventory.appendChild(row);
                    });
                }
            }

            // 显示特殊物品（treasures）
            if (gameData.treasures && Object.keys(gameData.treasures).length > 0) {
                const treasureItems = Object.entries(gameData.treasures).filter(([name, count]) => count > 0);

                if (treasureItems.length > 0) {
                    const separatorRow = document.createElement('tr');
                    separatorRow.innerHTML = `
                        <td colspan="6" style="background-color: #fef3c7; text-align: center; font-weight: bold; color: #92400e;">
                            ✨ 特殊物品收藏
                        </td>
                    `;
                    materialsInventory.appendChild(separatorRow);

                    treasureItems.forEach(([treasure, count]) => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${treasure}</td>
                            <td>-</td>
                            <td style="background-color: #fef3c7; font-weight: 600;">${count} ✓</td>
                            <td>打猎获得</td>
                            <td>-</td>
                            <td>
                                <span style="color: #92400e; font-size: 12px;">珍贵收藏品</span>
                            </td>
                        `;
                        materialsInventory.appendChild(row);
                    });
                }
            }
        }

        // 种植相关功能
        function waterPlot(plotIndex) {
            const plot = gameData.plots[plotIndex];
            plot.moisture = Math.min(100, plot.moisture + 30);
            renderFarmGrid();
        }

        function fertilizePlot(plotIndex) {
            const plot = gameData.plots[plotIndex];
            plot.fertility = Math.min(100, plot.fertility + 25);
            renderFarmGrid();
        }

        function showSeedModal(plotIndex) {
            const modal = document.getElementById('seed-modal');
            const seedGrid = document.getElementById('seed-grid');
            
            seedGrid.innerHTML = '';
            
            // 显示所有种子选项，包括库存为0的
            Object.entries(seedsInfo).forEach(([seedName, seedInfo]) => {
                const count = gameData.seeds[seedName] || 0;
                const seedOption = document.createElement('div');
                seedOption.className = 'seed-option';
                
                // 如果有库存，可以种植；如果没有库存，可以购买
                if (count > 0) {
                    seedOption.innerHTML = `
                        <div class="seed-name">${seedName}</div>
                        <div class="seed-info">库存: ${count}个</div>
                        <div class="seed-info">生长时间: ${Math.round(seedInfo.growTime / 1000)}秒</div>
                        <div class="seed-info" style="color: #6b7280;">点击种植</div>
                    `;
                    seedOption.onclick = () => plantSeedInPlot(plotIndex, seedName);
                } else {
                    seedOption.innerHTML = `
                        <div class="seed-name">${seedName}</div>
                        <div class="seed-info">价格: ${seedInfo.price}金币</div>
                        <div class="seed-info">生长时间: ${Math.round(seedInfo.growTime / 1000)}秒</div>
                        <div class="seed-info" style="color: #6b7280;">点击购买种植</div>
                    `;
                    seedOption.onclick = () => buySeedAndPlant(plotIndex, seedName);
                }
                
                seedGrid.appendChild(seedOption);
            });
            
            modal.style.display = 'block';
        }
        
        function buySeedAndPlant(plotIndex, seedName) {
            const price = seedsInfo[seedName].price;
            if (gameData.funds >= price) {
                // 购买种子
                gameData.funds -= price;
                const beforeSeedCount = gameData.seeds[seedName] || 0;
                gameData.seeds[seedName] = beforeSeedCount + 1;
                
                // 立即种植
                plantSeedInPlot(plotIndex, seedName);
                
                document.getElementById('current-funds').textContent = gameData.funds + ' 金币';
                addDebugLog(`购买并种植：${seedName}，花费${price}金币，直接种植到地块${plotIndex + 1}`);
                updateAllInventoryDisplay();
            } else {
                showAlert('金币不足！需要 ' + price + ' 金币', '购买失败', '💰');
                addDebugLog(`购买${seedName}失败：金币不足（需要${price}金币）`);
            }
        }

        function plantSeedInPlot(plotIndex, seedName) {
            const plot = gameData.plots[plotIndex];
            if (gameData.seeds[seedName] > 0) {
                const beforeSeedCount = gameData.seeds[seedName];
                gameData.seeds[seedName]--;
                const afterSeedCount = gameData.seeds[seedName];
                
                plot.state = 'growing';
                plot.plantType = seedName;
                plot.growthStage = 0;
                plot.plantTime = Date.now(); // 修复：使用plantTime而非stageStartTime
                plot.stageStartTime = Date.now(); // 保留兼容性
                
                const growTimeSeconds = Math.round(seedsInfo[seedName].growTime / 1000);
                addDebugLog(`种植操作：地块${plotIndex + 1}种植${seedName}，种子库存 ${beforeSeedCount} → ${afterSeedCount} (-1)，预计${growTimeSeconds}秒后成熟`);
                
                document.getElementById('seed-modal').style.display = 'none';
                renderFarmGrid();
                updateAllInventoryDisplay();
                saveGameDataToDatabase();
            }
        }

        // 统一的库存更新函数
        function updateAllInventoryDisplay() {
            renderMaterialsInventory();
            renderToppingsInventory();
            renderTeaInventory();
            renderCustomersTable();
            renderCatsTable();
            updateDebugDisplay();
        }

        function harvestPlot(plotIndex) {
            const plot = gameData.plots[plotIndex];
            if (plot.state === 'ready' && plot.plantType) {
                const yield = Math.floor(Math.random() * 5) + 3; // 3-7个
                const harvestedCrop = plot.plantType; // 先保存作物名称
                const beforeCount = gameData.inventory[plot.plantType] || 0;
                gameData.inventory[plot.plantType] = beforeCount + yield;
                const afterCount = gameData.inventory[plot.plantType];
                
                // 重置地块
                plot.state = 'empty';
                plot.plantType = null;
                plot.growthStage = 0;
                plot.plantTime = 0; // 重置种植时间
                plot.stageStartTime = 0;
                plot.moisture = Math.max(10, plot.moisture - 10);
                plot.fertility = Math.max(20, plot.fertility - 5);
                
                // 添加详细的调试信息
                addDebugLog(`收获操作：${harvestedCrop} ${beforeCount} → ${afterCount} (+${yield})`);
                
                // 立即更新所有显示
                renderFarmGrid();
                updateAllInventoryDisplay();
                
                showAlert(`收获了 ${yield} 个 ${harvestedCrop}！当前库存：${afterCount}个`, '收获成功', '🌾');
                
                // 保存到数据库
                saveGameDataToDatabase();
            }
        }

        function buySeed(material) {
            const price = seedsInfo[material].price;
            if (gameData.funds >= price) {
                gameData.funds -= price;
                const beforeSeedCount = gameData.seeds[material] || 0;
                gameData.seeds[material] = beforeSeedCount + 1;
                const afterSeedCount = gameData.seeds[material];
                
                document.getElementById('current-funds').textContent = gameData.funds + ' 金币';
                
                addDebugLog(`购买种子：${material} ${beforeSeedCount} → ${afterSeedCount} (+1)，花费${price}金币`);
                
                // 立即更新所有显示
                updateAllInventoryDisplay();
                showAlert(`购买了 1 个 ${material} 种子，花费 ${price} 金币`, '购买成功', '🌱');
                saveGameDataToDatabase();
            } else {
                showAlert('金币不足！', '购买失败', '💰');
                addDebugLog(`购买${material}种子失败：金币不足（需要${price}金币）`);
            }
        }

        function plantSeedFromInventory(material) {
            const emptyPlots = gameData.plots.filter(plot => plot.state === 'empty');
            if (emptyPlots.length === 0) {
                showAlert('没有空闲的种植区域！请先收获已成熟的作物。', '种植失败', '🚫');
                return;
            }

            if (gameData.seeds[material] <= 0) {
                showAlert(`没有${material}的种子！`, '种植失败', '🌱');
                return;
            }

            // 使用第一个空闲地块
            const plotIndex = gameData.plots.findIndex(plot => plot.state === 'empty');
            plantSeedInPlot(plotIndex, material);
        }

        // 炉灶制茶功能
        function showRecipeModal(stoveIndex) {
            const availableRecipes = Object.keys(gameData.teaRecipes).filter(recipe => {
                const ingredients = gameData.teaRecipes[recipe];
                return ingredients.every(ingredient => {
                    // 检查inventory（种植材料）和materials（打猎材料）
                    return (gameData.inventory[ingredient] > 0) || (gameData.materials && gameData.materials[ingredient] > 0);
                });
            });

            if (availableRecipes.length === 0) {
                showAlert('没有可制作的茶饮配方，请先种植并收获相应材料！', '制茶失败', '🍵');
                return;
            }

            const modal = document.getElementById('recipe-modal');
            const recipeGrid = document.getElementById('recipe-grid');
            
            recipeGrid.innerHTML = '';
            availableRecipes.forEach(recipe => {
                const ingredients = gameData.teaRecipes[recipe];
                const ingredientText = ingredients.join(' + ');
                
                const recipeOption = document.createElement('div');
                recipeOption.className = 'seed-option';
                recipeOption.innerHTML = `
                    <div class="seed-name">${recipe}</div>
                    <div class="seed-info">需要: ${ingredientText}</div>
                    <div class="seed-info">制作时间: 8秒</div>
                `;
                recipeOption.onclick = () => {
                    startCooking(stoveIndex, recipe);
                    modal.style.display = 'none';
                };
                recipeGrid.appendChild(recipeOption);
            });
            
            modal.style.display = 'block';
        }

        function startCooking(stoveIndex, recipeName) {
            const stove = gameData.stoves[stoveIndex];
            const ingredients = gameData.teaRecipes[recipeName];
            
            // 检查材料是否足够（检查inventory和materials）
            const insufficientMaterials = ingredients.filter(ingredient => {
                const inventoryCount = gameData.inventory[ingredient] || 0;
                const materialsCount = (gameData.materials && gameData.materials[ingredient]) || 0;
                return (inventoryCount + materialsCount) < 1;
            });

            if (insufficientMaterials.length > 0) {
                showAlert(`材料不足：${insufficientMaterials.join(', ')}`, '制茶失败', '📦');
                addDebugLog(`制茶失败：材料不足 ${insufficientMaterials.join(', ')}`);
                return;
            }
            
            // 消耗材料 - 详细记录每个材料的变化
            addDebugLog(`开始制作${recipeName}，消耗材料：`);
            ingredients.forEach(ingredient => {
                // 优先从materials中消耗（打猎材料），然后从inventory中消耗（种植材料）
                if (gameData.materials && gameData.materials[ingredient] > 0) {
                    const beforeCount = gameData.materials[ingredient];
                    gameData.materials[ingredient] = Math.max(0, beforeCount - 1);
                    const afterCount = gameData.materials[ingredient];
                    addDebugLog(`  - ${ingredient}(打猎): ${beforeCount} → ${afterCount} (-1)`);
                } else if (gameData.inventory[ingredient] > 0) {
                    const beforeCount = gameData.inventory[ingredient];
                    gameData.inventory[ingredient] = Math.max(0, beforeCount - 1);
                    const afterCount = gameData.inventory[ingredient];
                    addDebugLog(`  - ${ingredient}(种植): ${beforeCount} → ${afterCount} (-1)`);
                }
            });
            
            // 开始制茶
            stove.state = 'cooking';
            stove.recipe = recipeName;
            stove.startTime = Date.now();
            
            addDebugLog(`${recipeName}制作中，预计8秒完成`);
            
            // 立即更新所有显示
            renderStoves();
            updateAllInventoryDisplay();
            saveGameDataToDatabase();
        }

        // 案板加工功能
        function showProcessingModal(boardIndex = 0) {
            const availableRecipes = Object.keys(gameData.processingRecipes).filter(recipe => {
                const recipeData = gameData.processingRecipes[recipe];
                return recipeData.ingredients.every(ingredient => {
                    // 检查inventory（种植材料）和materials（打猎动物）
                    return (gameData.inventory[ingredient] > 0) || (gameData.materials && gameData.materials[ingredient] > 0);
                });
            });

            if (availableRecipes.length === 0) {
                showAlert('没有可加工的配方，请先种植并收获相应材料！', '加工失败', '⚙️');
                return;
            }

            const modal = document.getElementById('processing-modal');
            const processingGrid = document.getElementById('processing-grid');
            
            processingGrid.innerHTML = '';
            availableRecipes.forEach(recipe => {
                const recipeData = gameData.processingRecipes[recipe];
                const ingredients = recipeData.ingredients.join(' + ');
                const timeInSeconds = Math.round(recipeData.time / 1000);
                
                const processingOption = document.createElement('div');
                processingOption.className = 'seed-option';

                // 区分动物分解和小料加工的显示
                if (recipeData.outputs) {
                    // 动物分解配方
                    const outputText = recipeData.outputs.map(output => `${output.name}×${output.quantity}`).join(', ');
                    processingOption.innerHTML = `
                        <div class="seed-name">${recipe}</div>
                        <div class="seed-info">需要: ${ingredients}</div>
                        <div class="seed-info">产出: ${outputText}</div>
                        <div class="seed-info">分解时间: ${timeInSeconds}秒</div>
                        <div class="seed-info" style="color: #d2691e; font-size: 11px;">${recipeData.description}</div>
                    `;
                } else {
                    // 小料加工配方
                    processingOption.innerHTML = `
                        <div class="seed-name">${recipe}</div>
                        <div class="seed-info">需要: ${ingredients}</div>
                        <div class="seed-info">产出: ${recipeData.output}个</div>
                        <div class="seed-info">加工时间: ${timeInSeconds}秒</div>
                    `;
                }
                processingOption.onclick = () => {
                    startProcessing(recipe, boardIndex);
                    modal.style.display = 'none';
                };
                processingGrid.appendChild(processingOption);
            });
            
            modal.style.display = 'block';
        }

        function startProcessing(recipeName, boardIndex = 0) {
            const recipe = gameData.processingRecipes[recipeName];
            const board = gameData.processingBoards[boardIndex];

            // 消耗材料 - 详细记录每个材料的变化
            addDebugLog(`开始案板加工${recipeName}，消耗材料：`);
            recipe.ingredients.forEach(ingredient => {
                // 优先从materials中消耗（动物），然后从inventory中消耗（种植材料）
                if (gameData.materials && gameData.materials[ingredient] > 0) {
                    const beforeCount = gameData.materials[ingredient];
                    gameData.materials[ingredient] = Math.max(0, beforeCount - 1);
                    const afterCount = gameData.materials[ingredient];
                    addDebugLog(`  - ${ingredient}(动物): ${beforeCount} → ${afterCount} (-1)`);
                } else if (gameData.inventory[ingredient] > 0) {
                    const beforeCount = gameData.inventory[ingredient];
                    gameData.inventory[ingredient] = Math.max(0, beforeCount - 1);
                    const afterCount = gameData.inventory[ingredient];
                    addDebugLog(`  - ${ingredient}(种植): ${beforeCount} → ${afterCount} (-1)`);
                }
            });

            // 开始加工
            board.state = 'processing';
            board.recipe = recipeName;
            board.startTime = Date.now();
            board.duration = recipe.time;
            
            const timeInSeconds = Math.round(recipe.time / 1000);
            addDebugLog(`${recipeName}加工中，预计${timeInSeconds}秒完成，产出${recipe.output}个`);
            
            // 立即更新所有显示
            renderProcessingBoard();
            updateAllInventoryDisplay();
            saveGameDataToDatabase();
        }

        // 售出茶饮 - 智能服务顾客
        function serveTea(teaIndex) {
            const tea = gameData.madeTeas[teaIndex];
            
            // 检查是否有猫咪在场
            if (gameData.cats && gameData.cats.currentCat) {
                serveCustomer(tea.name);
                return;
            }
            
            // 检查是否有顾客在等待
            if (gameData.customer.active) {
                serveCustomer(tea.name);
                return;
            }
            
            // 没有顾客，直接售出
            const basePrice = 5;
            const tempBonus = tea.temperature === '热茶' ? 3 : 0;
            const totalPrice = basePrice + tempBonus;
            const beforeFunds = gameData.funds;
            const beforeTeaCount = gameData.madeTeas.length;
            
            gameData.funds += totalPrice;
            gameData.madeTeas.splice(teaIndex, 1);
            const afterFunds = gameData.funds;
            const afterTeaCount = gameData.madeTeas.length;
            
            addDebugLog(`直接售出茶饮：${tea.name}，茶饮库存 ${beforeTeaCount} → ${afterTeaCount} (-1)，金币 ${beforeFunds} → ${afterFunds} (+${totalPrice})`);
            
            document.getElementById('current-funds').textContent = gameData.funds + ' 金币';
            updateAllInventoryDisplay();
            showAlert(`售出 ${tea.name}，获得 ${totalPrice} 金币！`, '售出成功', '💰');
            saveGameDataToDatabase();
        }

        // 查看茶饮配方
        function checkTeaRecipes(material) {
            const recipesWithMaterial = Object.entries(gameData.teaRecipes).filter(([recipeName, ingredients]) => 
                ingredients.includes(material)
            );

            if (recipesWithMaterial.length === 0) {
                showAlert(`${material} 不能用于制作任何茶饮配方`, '查询结果', 'ℹ️');
                return;
            }

            const recipeList = recipesWithMaterial.map(([recipeName, ingredients]) => 
                `${recipeName}（需要：${ingredients.join(' + ')}）`
            ).join('\n');

            showWin95Modal('配方查询', `<div style="line-height: 1.6;"><strong>${material}</strong> 可用于制作以下茶饮：<br><br>${recipeList.replace(/\n/g, '<br>')}</div>`, '📖');
        }

        // 显示配方解锁状态
        function showRecipeUnlockStatus() {
            let statusText = "📋 茶饮配方解锁状态\n\n";
            
            // 已解锁的配方
            statusText += "🟢 已解锁配方：\n";
            const unlockedRecipes = Object.keys(gameData.teaRecipes);
            if (unlockedRecipes.length > 0) {
                unlockedRecipes.forEach(recipe => {
                    const ingredients = gameData.teaRecipes[recipe];
                    statusText += `  ✓ ${recipe}：${ingredients.join(' + ')}\n`;
                });
            } else {
                statusText += "  暂无已解锁配方\n";
            }
            
            statusText += "\n🔒 待解锁配方：\n";
            
            // 显示客户解锁进度
            if (gameData.customers) {
                Object.entries(gameData.customers).forEach(([customerName, customerData]) => {
                    const progress = `${customerData.visits}/${customerData.requiredVisits}`;
                    const isUnlocked = customerData.visits >= customerData.requiredVisits;
                    const statusIcon = isUnlocked ? "✅" : "⏳";
                    
                    statusText += `  ${statusIcon} ${customerData.unlockedRecipe} (${customerName}：${progress})\n`;
                });
            }
            
            statusText += "\n💡 提示：多次服务特定客户可解锁他们的专属配方！";
            
            showWin95Modal('游戏状态', `<div style="line-height: 1.6; white-space: pre-line;">${statusText}</div>`, '📊');
        }

        // 顾客和猫咪自动生成系统
        
        // 更新顾客状态（主循环调用）
        function updateCustomer() {
            // 如果有猫咪在场，不处理普通顾客逻辑
            if (gameData.cats && gameData.cats.currentCat) {
                const cat = gameData.cats.currentCat;
                const elapsed = Date.now() - cat.arrivalTime;

                // 如果猫咪还在停留期间，不处理普通顾客
                if (elapsed < cat.stayDuration) {
                    return;
                }
            }

            // 普通顾客逻辑
            if (gameData.customer.active) {
                const elapsed = Date.now() - gameData.customer.arrivalTime;
                const remaining = gameData.customer.patience - elapsed;

                if (remaining <= 0) {
                    // 顾客失去耐心离开
                    addDebugLog(`顾客 ${gameData.customer.name} 等得不耐烦，离开了`);
                    resetCustomer();
                } else {
                    // 更新显示
                    updateCustomerDisplay();
                }
            }
        }

        // 尝试生成新顾客（主循环调用）
        function trySpawnCustomer() {
            const now = Date.now();

            // 修改猫咪生成条件：每2-4天可能出现一次猫咪
            if (!gameData.cats.currentCat && 
                gameData.currentDay >= 2 && // 从第2天开始可能出现猫咪
                !gameData.cats.todayVisited &&
                (gameData.currentDay - (gameData.cats.lastCatDay || 0)) >= 2) { // 至少间隔2天
                
                // 每天有30%的概率生成猫咪（但最多4天一定会来一次）
                const daysSinceLastCat = gameData.currentDay - (gameData.cats.lastCatDay || 0);
                const catChance = daysSinceLastCat >= 4 ? 1.0 : 0.3; // 4天后必定出现，否则30%概率
                
                if (Math.random() < catChance) {
                    // 猫咪自动生成逻辑
                    const catNames = ['大橘猫', '狸花猫', '黑猫小手套', '小白猫', '大猫猫'];
                    const randomIndex = Math.floor(Math.random() * catNames.length);
                    const catName = catNames[randomIndex];
                    
                    gameData.cats.currentCat = {
                        name: catName,
                        arrivalTime: now,
                        stayDuration: 30000, // 停留30秒
                        fed: false
                    };
                    
                    gameData.cats.lastCatTime = now;
                    gameData.cats.lastCatDay = gameData.currentDay;
                    gameData.cats.todayVisited = true;
                    addDebugLog(`猫咪 ${catName} 来到了茶店！`);
                    updateCustomerDisplay();
                    return;
                }
            }

            // 如果有猫咪在场，不生成新顾客
            if (gameData.cats && gameData.cats.currentCat) {
                const cat = gameData.cats.currentCat;
                const elapsed = Date.now() - cat.arrivalTime;

                // 如果猫咪还在停留期间，不生成新顾客
                if (elapsed < cat.stayDuration) {
                    return;
                }
            }

            if (gameData.customer.active) return;

            if (now - gameData.lastCustomerTime < gameData.customerSpawnCooldown) return;

            // 80%概率生成顾客（大幅提升概率以便测试）
            if (Math.random() < 0.8) {
                spawnRandomCustomer();
                gameData.lastCustomerTime = now;
                addDebugLog('触发顾客生成检查 - 生成新顾客');
            } else {
                addDebugLog('触发顾客生成检查 - 这次没有生成顾客');
            }
        }

        // 生成随机顾客
        function spawnRandomCustomer() {
            // 70%概率生成特殊顾客（有名字的），便于测试访问记录功能
            const isVIP = Math.random() < 0.7;
            const customerName = isVIP
                ? gameData.customerNames[Math.floor(Math.random() * gameData.customerNames.length)]
                : "普通顾客";

            // 选择订单类型：茶饮或烤肉
            let orderType = 'tea';
            let orderChoice = '';

            // 如果烤肉架已解锁，30%概率点烤肉，70%概率点茶饮
            if (gameData.grillSystem && gameData.grillSystem.unlocked && Math.random() < 0.3) {
                // 检查是否有可用的烤肉类食品
                const availableGrilledFoods = gameData.madeTeas.filter(tea => tea.type === 'grilled');
                if (availableGrilledFoods.length > 0) {
                    orderType = 'grilled';
                    orderChoice = availableGrilledFoods[Math.floor(Math.random() * availableGrilledFoods.length)].name;
                } else {
                    // 没有烤肉类食品，回退到茶饮
                    orderType = 'tea';
                }
            }

            if (orderType === 'tea') {
                // 只从初始的简单配方中选择（避免选择未解锁的复杂配方）
                const basicRecipes = ['五味子饮', '柠檬茶'];
                orderChoice = basicRecipes[Math.floor(Math.random() * basicRecipes.length)];
            }

            // 修改耐心时间：普通顾客120秒，特殊顾客240秒
            const patience = isVIP ? 240000 : 120000;

            // 更新顾客状态
            gameData.customer = {
                active: true,
                name: customerName,
                isVIP: isVIP,
                orderType: orderType,
                teaChoice: orderType === 'tea' ? orderChoice : '',
                grilledChoice: orderType === 'grilled' ? orderChoice : '',
                toppingChoices: [],
                arrivalTime: Date.now(),
                patience: patience,
                maxPatience: patience,
                served: false
            };

            // 只有茶饮订单才需要小料
            if (orderType === 'tea') {
                // 随机选择0-2个小料
                const possibleToppings = [
                    "红糖", "薄荷叶", "姜丝", "柚子丝", "银耳丝", "柠檬片", "蜂蜜",
                    "冰糖", "乌龙茶包", "干桂花", "小圆子", "酒酿", "水蜜桃果肉", "黄芪片"
                ];

                const numToppings = Math.floor(Math.random() * 3); // 0-2个小料
                for (let i = 0; i < numToppings; i++) {
                    const topping = possibleToppings[Math.floor(Math.random() * possibleToppings.length)];
                    if (!gameData.customer.toppingChoices.includes(topping)) {
                        gameData.customer.toppingChoices.push(topping);
                    }
                }
            }

            // 显示顾客消息
            let customerMessage = `${customerName} 来到茶店，想要一杯 ${teaChoice}`;
            if (gameData.customer.toppingChoices.length > 0) {
                customerMessage += `，加${gameData.customer.toppingChoices.join('、')}`;
            }
            addDebugLog(customerMessage);

            updateCustomerDisplay();
        }

        // 更新顾客和访客状态显示
        function updateCustomerDisplay() {
            const currentCustomer = document.getElementById('current-customer');
            const customerStatus = document.getElementById('customer-status');
            
            // 检查是否有猫咪在场
            if (gameData.cats && gameData.cats.currentCat) {
                const cat = gameData.cats.currentCat;
                const elapsed = Date.now() - cat.arrivalTime;
                const remaining = Math.max(0, cat.stayDuration - elapsed);
                
                if (remaining > 0) {
                    const minutes = Math.floor(remaining / 60000);
                    const seconds = Math.floor((remaining % 60000) / 1000);
                    
                    if (currentCustomer) {
                        currentCustomer.innerHTML = `<tr><td><span class="badge bg-warning">${cat.name}</span></td><td class="text-end">猫咪访客</td><td class="text-end">${minutes}:${seconds.toString().padStart(2, '0')}</td><td><div class="progress"><div class="progress-bar bg-warning" style="width: ${(remaining / cat.stayDuration * 100)}%"></div></div></td></tr>`;
                    }
                    
                    if (customerStatus) {
                        // 检查是否有茶饮和小鱼干
                        const hasTeas = gameData.madeTeas.length > 0;
                        const toppingsCount = gameData.toppings['小鱼干'] || 0;
                        const materialsCount = (gameData.materials && gameData.materials['小鱼干']) || 0;
                        const hasFish = (toppingsCount + materialsCount) > 0;

                        customerStatus.innerHTML = `
                            <div class="alert alert-warning">
                                <div><strong>🐱 ${cat.name} 来访</strong></div>
                                <div style="margin: 10px 0;">可以喂食增加亲密度</div>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    <button class="action-btn" onclick="feedCatWithTea('${cat.name}')" ${hasTeas ? '' : 'disabled'}>
                                        ${hasTeas ? '🍵 喂茶饮' : '🍵 无茶饮'}
                                    </button>
                                    <button class="action-btn" onclick="feedCatWithFish('${cat.name}')" ${hasFish ? '' : 'disabled'}>
                                        ${hasFish ? '🐟 喂小鱼干' : '🐟 无小鱼干'}
                                    </button>
                                    <button class="action-btn" onclick="petCat('${cat.name}')">
                                        🤲 撸猫
                                    </button>
                                </div>
                            </div>
                        `;
                    }
                    return;
                } else {
                    // 猫咪离开
                    gameData.cats.currentCat = null;
                    addDebugLog('猫咪离开了茶店');
                }
            }
            
            // 普通顾客逻辑
            if (gameData.customer.active) {
                const elapsed = Date.now() - gameData.customer.arrivalTime;
                const remaining = Math.max(0, gameData.customer.patience - elapsed);
                const percentage = (remaining / gameData.customer.maxPatience) * 100;
                
                if (remaining <= 0) {
                    // 顾客失去耐心离开
                    addDebugLog('顾客 ' + gameData.customer.name + ' 等得不耐烦，离开了');
                    resetCustomer();
                    return;
                }
                
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                const vipText = gameData.customer.isVIP ? ' (VIP)' : '';
                
                // 显示订单内容
                const orderDisplay = gameData.customer.orderType === 'grilled'
                    ? gameData.customer.grilledChoice
                    : gameData.customer.teaChoice;

                if (currentCustomer) {
                    currentCustomer.innerHTML = `<tr><td><span class="badge bg-success">${gameData.customer.name}${vipText}</span></td><td class="text-end">${orderDisplay}</td><td class="text-end">${minutes}:${seconds.toString().padStart(2, '0')}</td><td><div class="progress"><div class="progress-bar bg-success" style="width: ${percentage}%"></div></div></td></tr>`;
                }

                if (customerStatus) {
                    let statusText = '';
                    if (gameData.customer.orderType === 'grilled') {
                        statusText = `顾客想要：${gameData.customer.grilledChoice}`;
                    } else {
                        const toppingText = gameData.customer.toppingChoices.length > 0
                            ? '，要加' + gameData.customer.toppingChoices.join('、')
                            : '';
                        statusText = `顾客想要：${gameData.customer.teaChoice}${toppingText}`;
                    }
                    // 检查进度状态
                    const progress = gameData.customer.progress || {};
                    const teaSubmitted = progress.teaSubmitted || false;
                    const toppingsSubmitted = progress.toppingsSubmitted || false;
                    
                    let serviceButtons = '';

                    if (gameData.customer.orderType === 'grilled') {
                        // 烤肉类订单
                        const hasGrilledFood = gameData.madeTeas.some(tea =>
                            tea.type === 'grilled' && tea.name === gameData.customer.grilledChoice);

                        addDebugLog(`🔍 检查烤肉库存：需要${gameData.customer.grilledChoice}，找到：${hasGrilledFood}`);
                        addDebugLog(`🔍 当前库存：${gameData.madeTeas.filter(tea => tea.type === 'grilled').map(tea => tea.name).join(', ')}`);

                        const grilledBtnText = hasGrilledFood ? '提供烤肉' : '制作中...';
                        const grilledBtnDisabled = hasGrilledFood ? '' : 'disabled';

                        serviceButtons = `
                            <button class="action-btn primary" onclick="serveGrilledFood()" ${grilledBtnDisabled}>
                                ${grilledBtnText}
                            </button>
                        `;
                    } else {
                        // 茶饮订单
                        const hasTea = gameData.madeTeas.some(tea => tea.name === gameData.customer.teaChoice);

                        // 检查小料是否充足
                        const hasAllToppings = gameData.customer.toppingChoices.every(topping =>
                            gameData.toppings[topping] && gameData.toppings[topping] > 0);

                        const teaBtnText = teaSubmitted ? '✓ 已提交' : (hasTea ? '提交茶饮' : '制作中...');
                        const teaBtnDisabled = teaSubmitted ? 'disabled' : (hasTea ? '' : 'disabled');

                        const toppingBtnText = toppingsSubmitted ? '✓ 已提交' : (hasAllToppings ? '提交小料' : '缺少小料');
                        const toppingBtnDisabled = toppingsSubmitted ? 'disabled' : (hasAllToppings ? '' : 'disabled');

                        // 完整服务按钮
                        const needsToppings = gameData.customer.toppingChoices.length > 0;
                        const canCompleteOrder = teaSubmitted && (!needsToppings || toppingsSubmitted);
                        const completeBtnText = canCompleteOrder ? '完成订单' : '准备中...';
                        const completeBtnDisabled = canCompleteOrder ? '' : 'disabled';

                        serviceButtons = `
                            <button class="action-btn" onclick="submitTeaOnly()" ${teaBtnDisabled}>
                                ${teaBtnText}
                            </button>
                            ${gameData.customer.toppingChoices.length > 0 ? `
                            <button class="action-btn" onclick="submitToppingsOnly()" ${toppingBtnDisabled}>
                                ${toppingBtnText}
                            </button>` : ''}
                            <button class="action-btn primary" onclick="serveCustomerFromButton()" ${completeBtnDisabled}>
                                ${completeBtnText}
                            </button>
                        `;
                    }

                    if (customerStatus) {
                        customerStatus.innerHTML = `
                            <div class="alert alert-info">
                                <div><strong>顾客需求：</strong>${statusText}</div>
                                <div class="mt-2" style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    ${serviceButtons}
                                </div>
                            </div>`;
                    }
                }
            } else {
                if (currentCustomer) {
                    currentCustomer.innerHTML = '<tr><td colspan="4" class="text-center text-muted">暂无顾客</td></tr>';
                }
                if (customerStatus) {
                    customerStatus.innerHTML = '<div class="alert alert-secondary">等待顾客到来...</div>';
                }
            }
        }

        // 重置顾客状态
        function resetCustomer() {
            gameData.customer = {
                active: false,
                name: "等待顾客到来",
                isVIP: false,
                teaChoice: null,
                toppingChoices: [],
                arrivalTime: 0,
                patience: 120000,
                maxPatience: 120000,
                served: false,
                progress: {} // 清除进度状态
            };
            gameData.lastCustomerTime = Date.now();
            updateCustomerDisplay();
        }

        // 从按钮服务顾客 - 完成整个订单
        function serveCustomerFromButton() {
            if (!gameData.customer.active) {
                addDebugLog('当前没有顾客');
                return;
            }
            
            const progress = gameData.customer.progress || {};
            const needsToppings = gameData.customer.toppingChoices.length > 0;
            
            // 检查是否所有必需项目都已提交
            if (!progress.teaSubmitted) {
                addDebugLog('茶饮尚未提交！');
                showAlert('请先提交茶饮！', '服务提醒', '🍵');
                return;
            }

            if (needsToppings && !progress.toppingsSubmitted) {
                addDebugLog('小料尚未提交！');
                showAlert('请先提交小料！', '服务提醒', '🧂');
                return;
            }
            
            // 计算收入
            const basePrice = 15;
            const toppingBonus = gameData.customer.toppingChoices.length * 2;
            const vipBonus = gameData.customer.isVIP ? 5 : 0;
            const totalPrice = basePrice + toppingBonus + vipBonus;
            
            gameData.funds += totalPrice;

            // 实时记录顾客访问到数据库
            const customerType = gameData.customerNames.includes(gameData.customer.name) ? 'vip' : 'normal';
            const customerName = gameData.customer.name;
            const teaServed = gameData.customer.teaChoice || '';
            const toppingsServed = gameData.customer.toppingChoices.join(', ') || '';

            // 立即记录到数据库
            recordCustomerVisitToDatabase(customerName, customerType, teaServed, toppingsServed, totalPrice);

            // 记录特殊顾客访问（不仅限于VIP）
            if (gameData.customerNames.includes(gameData.customer.name)) {
                if (!gameData.customerVisits) {
                    gameData.customerVisits = {};
                    addDebugLog('初始化customerVisits对象');
                }

                const oldCount = gameData.customerVisits[gameData.customer.name] || 0;
                gameData.customerVisits[gameData.customer.name] = oldCount + 1;
                const newCount = gameData.customerVisits[gameData.customer.name];

                // 同步更新customers表中的visits计数
                if (gameData.customers && gameData.customers[gameData.customer.name]) {
                    gameData.customers[gameData.customer.name].visits = newCount;
                }

                addDebugLog(`📊 ${gameData.customer.name} 访问次数更新：${oldCount} → ${newCount}`);

                // 检查配方解锁和特殊功能解锁
                checkRecipeUnlock(gameData.customer.name);
                checkSpecialFeatureUnlock(gameData.customer.name);

                // 检查彩蛋码触发
                checkEasterEggTrigger(gameData.customer.name);
            } else {
                // 普通顾客计数
                gameData.servedCustomers++;
                addDebugLog(`📊 普通顾客服务完成，总服务顾客数：${gameData.servedCustomers}`);
            }

            addDebugLog(`成功服务顾客 ${gameData.customer.name}，获得${totalPrice}金币`);
            showAlert(`订单完成！获得${totalPrice}金币`, '订单完成', '💰');

            resetCustomer();
            document.getElementById('current-funds').textContent = gameData.funds + ' 金币';
            updateAllInventoryDisplay();

            // 检查人数解锁
            checkCustomerCountUnlock();

            saveGameDataToDatabase();
        }

        // 只提交茶饮
        function submitTeaOnly() {
            if (!gameData.customer.active) {
                addDebugLog('当前没有顾客');
                return;
            }
            
            const requiredTea = gameData.customer.teaChoice;
            const tea = gameData.madeTeas.find(tea => tea.name === requiredTea);
            
            if (!tea) {
                addDebugLog(`没有制作好的${requiredTea}，请先制作！`);
                showAlert(`没有制作好的${requiredTea}，请先制作！`, '茶饮不足', '🍵');
                return;
            }
            
            // 消耗茶饮
            const teaIndex = gameData.madeTeas.findIndex(tea => tea.name === requiredTea);
            if (teaIndex !== -1) {
                gameData.madeTeas.splice(teaIndex, 1);
            }
            
            // 标记茶饮已提交
            if (!gameData.customer.progress) {
                gameData.customer.progress = {};
            }
            gameData.customer.progress.teaSubmitted = true;
            
            addDebugLog(`已提交茶饮：${requiredTea}`);
            showAlert(`已提交茶饮：${requiredTea}`, '提交成功', '✅');
            
            updateAllInventoryDisplay();
            updateCustomerDisplay();

            // 检查人数解锁
            checkCustomerCountUnlock();

            saveGameDataToDatabase();
        }

        // 只提交小料
        function submitToppingsOnly() {
            if (!gameData.customer.active) {
                addDebugLog('当前没有顾客');
                return;
            }
            
            const customerToppings = gameData.customer.toppingChoices || [];
            
            // 检查小料是否充足
            for (let topping of customerToppings) {
                if (!gameData.toppings[topping] || gameData.toppings[topping] <= 0) {
                    addDebugLog(`缺少顾客要求的小料：${topping}`);
                    showAlert(`缺少顾客要求的小料：${topping}`, '小料不足', '🧂');
                    return;
                }
            }
            
            // 消耗小料
            customerToppings.forEach(topping => {
                if (gameData.toppings[topping] > 0) {
                    gameData.toppings[topping]--;
                }
            });
            
            // 标记小料已提交
            if (!gameData.customer.progress) {
                gameData.customer.progress = {};
            }
            gameData.customer.progress.toppingsSubmitted = true;
            
            addDebugLog(`已提交小料：${customerToppings.join('、')}`);
            showAlert(`已提交小料：${customerToppings.join('、')}`, '提交成功', '✅');
            
            updateAllInventoryDisplay();
            updateCustomerDisplay();
            saveGameDataToDatabase();
        }

        // 服务顾客
        function serveCustomer(teaName) {
            if (gameData.cats && gameData.cats.currentCat) {
                // 喂食猫咪
                const cat = gameData.cats.currentCat;
                feedCat(cat.name, teaName);
                return;
            }

            if (!gameData.customer.active) {
                addDebugLog('当前没有顾客');
                return;
            }

            if (teaName !== gameData.customer.teaChoice) {
                addDebugLog(`顾客要的是 ${gameData.customer.teaChoice}，不是 ${teaName}`);
                return;
            }

            // 检查小料要求
            const customerToppings = gameData.customer.toppingChoices || [];
            for (let topping of customerToppings) {
                if (!gameData.toppings[topping] || gameData.toppings[topping] <= 0) {
                    addDebugLog(`缺少顾客要求的小料：${topping}`);
                    return;
                }
            }

            // 消耗小料
            customerToppings.forEach(topping => {
                if (gameData.toppings[topping] > 0) {
                    gameData.toppings[topping]--;
                }
            });

            // 计算收入
            const basePrice = 15;
            const toppingBonus = customerToppings.length * 2;
            const vipBonus = gameData.customer.isVIP ? 5 : 0;
            const totalPrice = basePrice + toppingBonus + vipBonus;

            gameData.funds += totalPrice;

            // 实时记录顾客访问到数据库
            const customerType = gameData.customerNames.includes(gameData.customer.name) ? 'vip' : 'normal';
            const customerName = gameData.customer.name;

            // 立即记录到数据库
            recordCustomerVisitToDatabase(customerName, customerType, '', toppingsText, totalPrice);

            // 记录特殊顾客访问（不仅限于VIP）
            if (gameData.customerNames.includes(gameData.customer.name)) {
                if (!gameData.customerVisits) {
                    gameData.customerVisits = {};
                    addDebugLog('初始化customerVisits对象');
                }

                const oldCount = gameData.customerVisits[gameData.customer.name] || 0;
                gameData.customerVisits[gameData.customer.name] = oldCount + 1;
                const newCount = gameData.customerVisits[gameData.customer.name];

                // 同步更新customers表中的visits计数
                if (gameData.customers && gameData.customers[gameData.customer.name]) {
                    gameData.customers[gameData.customer.name].visits = newCount;
                }

                addDebugLog(`📊 ${gameData.customer.name} 访问次数更新：${oldCount} → ${newCount}`);

                // 检查配方解锁和特殊功能解锁
                checkRecipeUnlock(gameData.customer.name);
                checkSpecialFeatureUnlock(gameData.customer.name);
            } else {
                // 普通顾客计数
                gameData.servedCustomers++;
                addDebugLog(`📊 普通顾客服务完成，总服务顾客数：${gameData.servedCustomers}`);
            }

            addDebugLog(`成功服务顾客 ${gameData.customer.name}，获得${totalPrice}金币`);

            // 从成品茶中移除
            const teaIndex = gameData.madeTeas.findIndex(tea => tea.name === teaName);
            if (teaIndex !== -1) {
                gameData.madeTeas.splice(teaIndex, 1);
            }

            resetCustomer();
            document.getElementById('current-funds').textContent = gameData.funds + ' 金币';
            updateAllInventoryDisplay();
        }

        // 喂食猫咪
        function feedCat(catName, teaName) {
            if (!gameData.cats.intimacy[catName]) {
                gameData.cats.intimacy[catName] = 0;
            }
            if (!gameData.cats.feedCount[catName]) {
                gameData.cats.feedCount[catName] = 0;
            }

            gameData.cats.intimacy[catName] = Math.min(5000, gameData.cats.intimacy[catName] + 10);
            gameData.cats.feedCount[catName]++;
            gameData.cats.lastSeen[catName] = Date.now();

            // 从成品茶中移除
            const teaIndex = gameData.madeTeas.findIndex(tea => tea.name === teaName);
            if (teaIndex !== -1) {
                gameData.madeTeas.splice(teaIndex, 1);
            }

            const intimacy = gameData.cats.intimacy[catName];
            let gifts = [];
            
            // 根据亲密度给予奖励
            if (intimacy >= 500 && intimacy < 1000) {
                gifts = ['小鱼干'];
                gameData.toppings['蜂蜜'] = (gameData.toppings['蜂蜜'] || 0) + 1;
            } else if (intimacy >= 1000 && intimacy < 1500) {
                gifts = ['小鱼干', '蜂蜜'];
                gameData.funds += 5;
            } else if (intimacy >= 1500) {
                gifts = ['金币', '稀有材料'];
                gameData.funds += 10;
            }

            addDebugLog(`喂食了 ${catName}，亲密度增加！当前亲密度：${intimacy}`);
            if (gifts.length > 0) {
                addDebugLog(`获得了猫咪的礼物：${gifts.join('、')}`);
            }

            document.getElementById('current-funds').textContent = gameData.funds + ' 金币';
            updateAllInventoryDisplay();
        }

        // 用茶饮喂食访客猫咪
        function feedCatWithTea(catName) {
            if (gameData.madeTeas.length === 0) {
                showAlert('没有茶饮可以喂给猫咪！请先制作一些茶饮。', '茶饮不足', '🍵');
                return;
            }

            // 使用第一个可用的茶饮
            const tea = gameData.madeTeas[0];
            feedCat(catName, tea.name);

            // 猫咪离开
            gameData.cats.currentCat = null;
            addDebugLog(`${catName} 吃饱了，满足地离开了`);

            showAlert(`用${tea.name}喂食了${catName}，亲密度增加！`, '喂食成功', '🐱');
            updateCustomerDisplay();
            saveGameDataToDatabase();
        }

        // 用小鱼干喂访客猫咪
        function feedCatWithFish(catName) {
            // 检查是否有小鱼干（检查toppings和materials两个库存）
            const toppingsCount = gameData.toppings['小鱼干'] || 0;
            const materialsCount = (gameData.materials && gameData.materials['小鱼干']) || 0;
            const totalFishCount = toppingsCount + materialsCount;

            if (totalFishCount <= 0) {
                showAlert('没有小鱼干了！请打猎获得或到小料商店购买。', '物品不足', '🐟');
                return;
            }

            // 初始化猫咪数据
            if (!gameData.cats.intimacy[catName]) {
                gameData.cats.intimacy[catName] = 0;
            }
            if (!gameData.cats.feedCount[catName]) {
                gameData.cats.feedCount[catName] = 0;
            }

            // 增加亲密度（小鱼干效果更好）
            gameData.cats.intimacy[catName] = Math.min(5000, gameData.cats.intimacy[catName] + 20);
            gameData.cats.feedCount[catName]++;
            gameData.cats.lastSeen[catName] = Date.now();

            // 消耗小鱼干（优先从materials中消耗，然后从toppings中消耗）
            if (gameData.materials && gameData.materials['小鱼干'] > 0) {
                const beforeCount = gameData.materials['小鱼干'];
                gameData.materials['小鱼干']--;
                const afterCount = gameData.materials['小鱼干'];
                addDebugLog(`消耗小鱼干(打猎): ${beforeCount} → ${afterCount} (-1)`);
            } else if (gameData.toppings['小鱼干'] > 0) {
                const beforeCount = gameData.toppings['小鱼干'];
                gameData.toppings['小鱼干']--;
                const afterCount = gameData.toppings['小鱼干'];
                addDebugLog(`消耗小鱼干(购买): ${beforeCount} → ${afterCount} (-1)`);
            }

            addDebugLog(`用小鱼干喂食了 ${catName}，亲密度增加20！`);

            // 猫咪离开
            gameData.cats.currentCat = null;
            addDebugLog(`${catName} 吃饱了，满足地离开了`);

            showAlert(`用小鱼干喂食了${catName}，亲密度大幅增加！`, '喂食成功', '🐱');
            updateCustomerDisplay();
            updateAllInventoryDisplay();
            saveGameDataToDatabase();
        }

        // 撸访客猫咪
        function petCat(catName) {
            // 初始化猫咪数据
            if (!gameData.cats.intimacy[catName]) {
                gameData.cats.intimacy[catName] = 0;
            }

            // 增加少量亲密度
            gameData.cats.intimacy[catName] = Math.min(5000, gameData.cats.intimacy[catName] + 5);
            gameData.cats.lastSeen[catName] = Date.now();

            addDebugLog(`撸了撸 ${catName}，亲密度增加5`);

            // 猫咪离开
            gameData.cats.currentCat = null;
            addDebugLog(`${catName} 享受了一番，满足地离开了`);

            showAlert(`撸了撸${catName}，它很开心！`, '互动成功', '🐱');
            updateCustomerDisplay();
            saveGameDataToDatabase();
        }

        // 用小鱼干喂猫（原版函数，用于猫咪管理界面）
        function feedCatWithFish() {
            const selectedCatDiv = document.getElementById('selected-cat');
            if (!selectedCatDiv || !selectedCatDiv.innerHTML.includes('cat-name')) {
                showAlert('请先选择一只猫咪！', '猫咪系统', '🐱');
                return;
            }

            // 检查是否有小鱼干（检查toppings和materials两个库存）
            const toppingsCount = gameData.toppings['小鱼干'] || 0;
            const materialsCount = (gameData.materials && gameData.materials['小鱼干']) || 0;
            const totalFishCount = toppingsCount + materialsCount;

            if (totalFishCount <= 0) {
                showAlert('没有小鱼干了！请打猎获得或到小料商店购买。', '物品不足', '🐟');
                return;
            }

            // 获取当前选中的猫咪名称
            const catNameElement = selectedCatDiv.querySelector('.cat-name');
            if (!catNameElement) {
                showAlert('无法获取猫咪信息，请重新选择！', '系统错误', '❌');
                return;
            }
            
            const catName = catNameElement.textContent;

            // 确保猫咪数据存在
            if (!gameData.cats[catName]) {
                gameData.cats[catName] = {
                    avatar: ['🧡', '🐱', '🖤', '🤍', '😺'][['大橘猫', '狸花猫', '黑猫小手套', '小白猫', '大猫猫'].indexOf(catName)],
                    intimacy: 0,
                    lastGift: null,
                    gifts: ['金币', '种子', '金币', '种子']
                };
            }

            const cat = gameData.cats[catName];
            const beforeIntimacy = cat.intimacy;

            // 消耗小鱼干（优先从materials中消耗，然后从toppings中消耗）
            if (gameData.materials && gameData.materials['小鱼干'] > 0) {
                const beforeCount = gameData.materials['小鱼干'];
                gameData.materials['小鱼干']--;
                const afterCount = gameData.materials['小鱼干'];
                addDebugLog(`消耗小鱼干(打猎): ${beforeCount} → ${afterCount} (-1)`);
            } else if (gameData.toppings['小鱼干'] > 0) {
                const beforeCount = gameData.toppings['小鱼干'];
                gameData.toppings['小鱼干']--;
                const afterCount = gameData.toppings['小鱼干'];
                addDebugLog(`消耗小鱼干(购买): ${beforeCount} → ${afterCount} (-1)`);
            }

            // 小鱼干比茶饮更受猫咪喜爱，亲密度增加更多
            const intimacyGain = Math.floor(Math.random() * 50) + 50; // 50-99点亲密度
            cat.intimacy = Math.min(5000, cat.intimacy + intimacyGain);

            // 同步到旧结构保证兼容性
            if (!gameData.cats.intimacy) {
                gameData.cats.intimacy = {};
            }
            gameData.cats.intimacy[catName] = cat.intimacy;

            const intimacy = cat.intimacy;
            // 检查是否达到里程碑并给予礼物
            const milestones = [500, 1500, 3000, 5000];
            const reachedMilestone = milestones.find(milestone =>
                beforeIntimacy < milestone && cat.intimacy >= milestone
            );

            addDebugLog(`用小鱼干喂食了 ${catName}，亲密度 ${beforeIntimacy} → ${intimacy} (+${intimacyGain})`);

            if (reachedMilestone) {
                // 达到里程碑，给予特殊礼物
                let gift = '';
                let giftDescription = '';

                if (reachedMilestone === 500) {
                    gift = '小鱼干';
                    gameData.toppings['小鱼干'] = (gameData.toppings['小鱼干'] || 0) + 5;
                    giftDescription = '5个小鱼干';
                } else if (reachedMilestone === 1500) {
                    gift = '金币';
                    const goldReward = 80;
                    gameData.funds += goldReward;
                    giftDescription = `${goldReward}金币`;
                } else if (reachedMilestone === 3000) {
                    gift = '稀有种子 + 稻香村解锁';
                    const rareSeeds = ['五味子', '洛神花', '玫瑰花'];
                    const randomSeed = rareSeeds[Math.floor(Math.random() * rareSeeds.length)];
                    gameData.seeds[randomSeed] = (gameData.seeds[randomSeed] || 0) + 3;
                    giftDescription = `3个${randomSeed}种子`;

                    // 解锁稻香村
                    if (!gameData.riceVillage) {
                        gameData.riceVillage = {
                            unlocked: true,
                            maxIntimacyCats: []
                        };
                    }

                    // 添加到满级猫咪列表
                    if (!gameData.riceVillage.maxIntimacyCats.includes(catName)) {
                        gameData.riceVillage.maxIntimacyCats.push(catName);
                        addDebugLog(`🏮 ${catName}达到3000亲密度，解锁稻香村！`);

                        // 显示稻香村解锁提示
                        setTimeout(() => {
                            const unlockContent = `
                                <div style="text-align: center; line-height: 1.6;">
                                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">🏮 重大发现！</h3>
                                    <div style="margin-bottom: 15px; padding: 12px; background: #f0f9ff; border: 1px inset #c0c0c0;">
                                        <div style="font-weight: bold; color: #d2691e; margin-bottom: 8px;">${catName} 亲密度达到3000！</div>
                                        <div style="color: #1e40af; font-weight: bold; margin-bottom: 8px;">🏮 解锁稻香村！</div>
                                        <div style="color: #666; font-size: 12px;">与猫咪伙伴一起踏上冒险之旅</div>
                                    </div>
                                </div>
                            `;
                            showWin95Modal('稻香村解锁', unlockContent, '🏮');
                            updateRiceVillageDisplay();
                        }, 2000);
                    }
                } else if (reachedMilestone === 5000) {
                    gift = '终极礼物';
                    gameData.funds += 150;
                    gameData.toppings['小鱼干'] = (gameData.toppings['小鱼干'] || 0) + 15;
                    giftDescription = '150金币 + 15个小鱼干';
                }

                cat.lastGift = giftDescription;
                addDebugLog(`🎁 ${catName}达到${reachedMilestone}亲密度里程碑！赠送了：${giftDescription}`);

                showWin95Modal('猫咪里程碑', `<div style="text-align: center; line-height: 1.6;"><div style="font-size: 12px; margin-bottom: 10px;">🎉 ${catName} 达到 ${reachedMilestone} 亲密度里程碑！</div><div style="color: #d4af37; font-weight: bold;">获得奖励：${giftDescription}</div></div>`, '🎁');
            }

            // 更新显示
            document.getElementById('current-funds').textContent = gameData.funds + ' 金币';
            updateAllInventoryDisplay();
            renderCatsTable();
            
            // 重新选择猫咪以更新互动区域显示
            selectCatForInteraction(catName);
            renderSelectedCat();
            
            // 保存数据
            saveGameDataToDatabase();
        }

        // 更新稻香村显示
        function updateRiceVillageDisplay() {
            const riceVillageSection = document.getElementById('rice-village-section');

            // 检查是否应该解锁稻香村
            checkAndUnlockRiceVillage();

            if (gameData.riceVillage && gameData.riceVillage.unlocked) {
                riceVillageSection.style.display = 'block';
                addDebugLog('🏮 稻香村入口已显示');
            } else {
                riceVillageSection.style.display = 'none';
            }
        }

        // 检查并解锁稻香村
        function checkAndUnlockRiceVillage() {
            console.log('检查稻香村解锁条件...');

            // 先看看localStorage里都有什么
            console.log('localStorage所有键:', Object.keys(localStorage));

            // 检查gameData里是否有猫咪
            if (gameData && gameData.cats) {
                console.log('gameData.cats:', gameData.cats);
            }

            // 从gameData.cats中检查猫咪亲密度
            let maxIntimacyCat = null;

            if (gameData && gameData.cats) {
                console.log('检查gameData.cats中的猫咪...');

                // gameData.cats是对象，不是数组，需要遍历属性
                for (const catName in gameData.cats) {
                    const cat = gameData.cats[catName];
                    if (cat && typeof cat === 'object' && cat.intimacy) {
                        console.log(`检查猫咪: ${catName}, 亲密度: ${cat.intimacy}`);

                        if (cat.intimacy >= 3000) {
                            maxIntimacyCat = { name: catName, intimacy: cat.intimacy, ...cat };
                            console.log(`发现符合条件的猫咪: ${catName} (${cat.intimacy})`);
                            break; // 找到一只就够了
                        }
                    }
                }
            }

            console.log('最终找到的3000+亲密度猫咪:', maxIntimacyCat);

            if (maxIntimacyCat && (!gameData.riceVillage || !gameData.riceVillage.unlocked)) {
                console.log('满足解锁条件，开始解锁稻香村...');
                // 解锁稻香村
                if (!gameData.riceVillage) {
                    gameData.riceVillage = {
                        unlocked: true,
                        maxIntimacyCats: []
                    };
                } else {
                    gameData.riceVillage.unlocked = true;
                }

                // 添加到满级猫咪列表
                if (!gameData.riceVillage.maxIntimacyCats.includes(maxIntimacyCat.name)) {
                    gameData.riceVillage.maxIntimacyCats.push(maxIntimacyCat.name);
                    addDebugLog(`🏮 检测到${maxIntimacyCat.name}已达到3000亲密度，解锁稻香村！`);

                    // 显示稻香村解锁提示
                    setTimeout(() => {
                        const unlockContent = `
                            <div style="text-align: center; line-height: 1.6;">
                                <h3 style="color: #0040c0; margin: 0 0 15px 0;">🏮 重大发现！</h3>
                                <div style="margin-bottom: 15px; padding: 12px; background: #f0f9ff; border: 1px inset #c0c0c0;">
                                    <div style="font-weight: bold; color: #d2691e; margin-bottom: 8px;">${maxIntimacyCat.name} 亲密度已达到3000！</div>
                                    <div style="color: #1e40af; font-weight: bold; margin-bottom: 8px;">🏮 解锁稻香村！</div>
                                    <div style="color: #666; font-size: 12px;">与猫咪伙伴一起踏上冒险之旅</div>
                                </div>
                            </div>
                        `;
                        showWin95Modal('稻香村解锁', unlockContent, '🏮');
                    }, 1000);
                }

                // 保存数据
                saveGameDataToDatabase();
            }
        }

        // 进入稻香村
        function enterRiceVillage() {
            if (!gameData.riceVillage || !gameData.riceVillage.unlocked) {
                showAlert('稻香村尚未解锁！需要任意猫咪达到3000亲密度。', '未解锁', '🏮');
                return;
            }

            // 检查是否已经有稻香村数据（说明已经进入过）
            const riceVillageData = localStorage.getItem('riceVillageData');
            if (riceVillageData) {
                try {
                    const data = JSON.parse(riceVillageData);
                    if (data.cat && data.cat.name && data.cat.name !== "猫咪伙伴") {
                        // 已经有猫咪名字，直接进入稻香村
                        console.log('检测到已有稻香村数据，直接进入');
                        window.location.href = `rice_village.html?catName=${encodeURIComponent(data.cat.name)}`;
                        return;
                    }
                } catch (e) {
                    console.log('稻香村数据解析失败，继续正常流程');
                }
            }

            const maxIntimacyCats = gameData.riceVillage.maxIntimacyCats || [];
            if (maxIntimacyCats.length === 0) {
                showAlert('没有达到最高亲密度的猫咪！', '无法进入', '🏮');
                return;
            }

            if (maxIntimacyCats.length === 1) {
                // 只有一只猫咪，直接进入命名流程
                const catName = maxIntimacyCats[0];
                showCatNamingDialog(catName);
            } else {
                // 多只猫咪，显示选择界面
                showCatSelectionDialog(maxIntimacyCats);
            }
        }

        // 显示猫咪选择对话框
        function showCatSelectionDialog(cats) {
            let catOptions = '';
            cats.forEach(cat => {
                catOptions += `<button class="action-btn" onclick="selectCatForRiceVillage('${cat}')" style="margin: 5px; padding: 10px 15px;">${cat}</button>`;
            });

            const selectionContent = `
                <div style="text-align: center; line-height: 1.6;">
                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">🏮 选择猫咪伙伴</h3>
                    <div style="margin-bottom: 15px; padding: 12px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                        <div style="color: #666; margin-bottom: 15px;">选择一只猫咪作为你的冒险伙伴：</div>
                        ${catOptions}
                    </div>
                </div>
            `;
            showWin95Modal('选择猫咪伙伴', selectionContent, '🏮');
        }

        // 选择猫咪进入稻香村
        function selectCatForRiceVillage(catName) {
            closeWin95Modal();
            showCatNamingDialog(catName);
        }

        // 显示猫咪命名对话框
        function showCatNamingDialog(catName) {
            const namingContent = `
                <div style="text-align: center; line-height: 1.6;">
                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">🏮 为猫咪起名</h3>
                    <div style="margin-bottom: 15px; padding: 12px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                        <div style="color: #666; margin-bottom: 15px;">为你的伙伴 ${catName} 起一个冒险名字：</div>
                        <input type="text" id="cat-adventure-name" placeholder="输入猫咪的冒险名字"
                               style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 200px; margin-bottom: 15px;">
                        <br>
                        <button class="action-btn primary" onclick="confirmCatName('${catName}')">确认并进入稻香村</button>
                        <button class="action-btn" onclick="closeWin95Modal()">取消</button>
                    </div>
                </div>
            `;
            showWin95Modal('猫咪命名', namingContent, '🏮');

            // 聚焦到输入框
            setTimeout(() => {
                const nameInput = document.getElementById('cat-adventure-name');
                if (nameInput) {
                    nameInput.focus();
                    nameInput.value = catName; // 默认使用原名
                }
            }, 100);
        }

        // 确认猫咪名字并进入稻香村
        function confirmCatName(originalCatName) {
            const nameInput = document.getElementById('cat-adventure-name');
            const adventureName = nameInput ? nameInput.value.trim() : '';

            if (!adventureName) {
                showAlert('请输入猫咪的冒险名字！', '名字不能为空', '🏮');
                return;
            }

            // 保存猫咪冒险名字
            if (!gameData.riceVillage.catNames) {
                gameData.riceVillage.catNames = {};
            }
            gameData.riceVillage.catNames[originalCatName] = adventureName;

            addDebugLog(`🏮 ${originalCatName} 的冒险名字设为：${adventureName}`);

            // 保存数据
            saveGameDataToDatabase();

            // 关闭对话框
            closeWin95Modal();

            // 进入稻香村
            window.open(`rice_village.html?catName=${encodeURIComponent(adventureName)}`, '_blank');
        }

        // 检查配方解锁
        function checkRecipeUnlock(customerName) {
            if (!gameData.customerVisits || !gameData.recipeUnlockRules) return;

            const visitCount = gameData.customerVisits[customerName] || 0;
            
            Object.keys(gameData.recipeUnlockRules).forEach(recipeName => {
                const rule = gameData.recipeUnlockRules[recipeName];
                
                if (rule.customer === customerName && 
                    visitCount >= rule.visitsRequired &&
                    !Object.keys(gameData.teaRecipes).includes(recipeName)) {
                    
                    // 检查解锁几率
                    const shouldUnlock = visitCount >= rule.guaranteedOnVisit || Math.random() < rule.chance;
                    
                    if (shouldUnlock) {
                        // 添加到茶饮配方数据
                        switch(recipeName) {
                            case '洛神玫瑰饮':
                                gameData.teaRecipes[recipeName] = ['洛神花', '玫瑰花', '山楂'];
                                break;
                            case '桂圆红枣茶':
                                gameData.teaRecipes[recipeName] = ['桂圆', '红枣', '枸杞'];
                                break;
                            case '焦香大麦茶':
                                gameData.teaRecipes[recipeName] = ['大麦'];
                                break;
                            case '三花决明茶':
                                gameData.teaRecipes[recipeName] = ['菊花', '金银花', '决明子', '枸杞'];
                                break;
                            case '薄荷甘草凉茶':
                                gameData.teaRecipes[recipeName] = ['薄荷', '甘草'];
                                break;
                            case '陈皮姜米茶':
                                gameData.teaRecipes[recipeName] = ['陈皮', '生姜'];
                                break;
                            case '冬瓜荷叶饮':
                                gameData.teaRecipes[recipeName] = ['冬瓜', '荷叶', '薏米'];
                                break;
                            case '古法酸梅汤':
                                gameData.teaRecipes[recipeName] = ['乌梅', '山楂', '陈皮', '甘草', '桂花'];
                                break;
                            case '小吊梨汤':
                                gameData.teaRecipes[recipeName] = ['雪花梨', '银耳', '话梅', '枸杞'];
                                break;
                            // 神秘顾客配方
                            case '高级茶饮':
                                gameData.teaRecipes[recipeName] = ['龙井茶', '人参', '灵芝', '蜂蜜'];
                                break;
                            case '特制茶饮':
                                gameData.teaRecipes[recipeName] = ['普洱茶', '何首乌', '当归', '红枣'];
                                break;
                            case '动物茶饮':
                                gameData.teaRecipes[recipeName] = ['野生茶叶', '松子', '核桃', '蜂蜜'];
                                break;
                        }
                        
                        addDebugLog(`🎉 解锁新配方：${recipeName}！`);

                        // 神秘顾客列表
                        const mysteriousCustomers = ['姬别情', '池九信', '狸怒'];

                        if (mysteriousCustomers.includes(customerName)) {
                            // 神秘顾客只显示配方解锁，不显示故事
                            const mysteriousContent = `
                                <div style="text-align: center; line-height: 1.6;">
                                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">🎉 解锁新配方：${recipeName}</h3>
                                    <div style="margin-bottom: 15px; padding: 12px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                                        <div style="color: #666; margin-bottom: 8px;">神秘顾客 ${customerName}</div>
                                        <div style="font-style: italic; color: #444;">
                                            ${customerName === '姬别情' ? '神秘的技术专家，擅长信息收集' :
                                              customerName === '池九信' ? '学者型人物，知识渊博' :
                                              '与动物有特殊联系的神秘角色'}
                                        </div>
                                    </div>
                                    <div style="color: #888; font-size: 12px;">
                                        神秘顾客的故事隐藏在迷雾中...
                                    </div>
                                </div>
                            `;
                            showWin95Modal('神秘配方解锁', mysteriousContent, '🔮');
                        } else {
                            // 普通顾客显示完整故事
                            const story = gameData.customerStories[customerName];
                            if (story) {
                                const unlockContent = `
                                    <div style="text-align: center; margin-bottom: 15px;">
                                        <h3 style="color: #0040c0; margin: 0;">🎉 解锁新配方：${recipeName}</h3>
                                    </div>
                                    <div style="text-align: left; line-height: 1.6;">
                                        <h4 style="margin: 10px 0 5px 0; color: #0040c0;">${story.title}</h4>
                                        <div style="margin-bottom: 12px; padding: 8px; background: #f0f0f0; border: 1px inset #c0c0c0; font-style: italic;">
                                            ${story.content}
                                        </div>
                                        <div style="margin-bottom: 8px;">
                                            <strong>茶饮功效：</strong><br>
                                            <span style="color: #006600;">${story.effect}</span>
                                        </div>
                                    </div>
                                `;
                                showWin95Modal(`${customerName} 的故事`, unlockContent, '📖');
                            } else {
                                showAlert(`🎉 恭喜！解锁新配方：${recipeName}`, '配方解锁', '🎉');
                            }
                        }
                    }
                }
            });
        }



        // 选择猫咪进行互动
        function selectCatForInteraction(catName) {
            const selectedCatDiv = document.getElementById('selected-cat');
            const catData = gameData.cats[catName];
            const intimacy = catData ? catData.intimacy : 0;

            // 计算等级和名称
            let level = 1;
            let levelName = '陌生';
            if (intimacy >= 5000) {
                level = 5;
                levelName = '挚友';
            } else if (intimacy >= 3000) {
                level = 4;
                levelName = '亲密';
            } else if (intimacy >= 1500) {
                level = 3;
                levelName = '友好';
            } else if (intimacy >= 500) {
                level = 2;
                levelName = '熟悉';
            }

            // 计算下一个里程碑的进度
            let nextMilestone = 500;
            let progressInLevel = intimacy;
            if (intimacy >= 5000) {
                nextMilestone = 5000;
                progressInLevel = 5000;
            } else if (intimacy >= 3000) {
                nextMilestone = 5000;
                progressInLevel = intimacy - 3000;
            } else if (intimacy >= 1500) {
                nextMilestone = 3000;
                progressInLevel = intimacy - 1500;
            } else if (intimacy >= 500) {
                nextMilestone = 1500;
                progressInLevel = intimacy - 500;
            }

            const progressPercent = intimacy >= 5000 ? 100 : (progressInLevel / (nextMilestone - (intimacy >= 3000 ? 3000 : intimacy >= 1500 ? 1500 : intimacy >= 500 ? 500 : 0))) * 100;

            selectedCatDiv.innerHTML = `
                <div class="cat-name" style="font-size: 14px; font-weight: 600; margin-bottom: 10px;">${catName}</div>
                <div class="cat-intimacy" style="margin-bottom: 10px;">
                    亲密度：${intimacy}/5000 (${levelName} Lv.${level})
                    <div class="intimacy-bar">
                        <div class="intimacy-progress" style="width: ${Math.min(100, progressPercent)}%;"></div>
                    </div>
                    ${intimacy < 5000 ? `距离下一里程碑：${nextMilestone - intimacy}` : '已达到最高等级！'}
                </div>
                <div class="cat-status" style="color: #6c757d; font-size: 12px;">
                    ${catData && catData.lastGift ? `上次礼物：${catData.lastGift}` : '还没有收到过礼物'}
                </div>
            `;

            gameData.selectedCat = catName;
            addDebugLog(`选择了猫咪：${catName} 进行互动`);
        }

        // 渲染选中的猫咪显示区域
        function renderSelectedCat() {
            if (!gameData.selectedCat) return;

            const selectedCatDiv = document.getElementById('selected-cat');
            const catData = gameData.cats[gameData.selectedCat];
            const intimacy = catData ? catData.intimacy : 0;

            // 计算等级和名称
            let level = 1;
            let levelName = '陌生';
            if (intimacy >= 5000) {
                level = 5;
                levelName = '挚友';
            } else if (intimacy >= 3000) {
                level = 4;
                levelName = '亲密';
            } else if (intimacy >= 1500) {
                level = 3;
                levelName = '友好';
            } else if (intimacy >= 500) {
                level = 2;
                levelName = '熟悉';
            }

            // 计算下一个里程碑的进度
            let nextMilestone = 500;
            let progressInLevel = intimacy;
            if (intimacy >= 5000) {
                nextMilestone = 5000;
                progressInLevel = 5000;
            } else if (intimacy >= 3000) {
                nextMilestone = 5000;
                progressInLevel = intimacy - 3000;
            } else if (intimacy >= 1500) {
                nextMilestone = 3000;
                progressInLevel = intimacy - 1500;
            } else if (intimacy >= 500) {
                nextMilestone = 1500;
                progressInLevel = intimacy - 500;
            }

            const progressPercent = intimacy >= 5000 ? 100 : (progressInLevel / (nextMilestone - (intimacy >= 3000 ? 3000 : intimacy >= 1500 ? 1500 : intimacy >= 500 ? 500 : 0))) * 100;

            selectedCatDiv.innerHTML = `
                <div class="cat-name" style="font-size: 14px; font-weight: 600; margin-bottom: 10px;">${gameData.selectedCat}</div>
                <div class="cat-intimacy" style="margin-bottom: 10px;">
                    亲密度：${intimacy}/5000 (${levelName} Lv.${level})
                    <div class="intimacy-bar">
                        <div class="intimacy-progress" style="width: ${Math.min(100, progressPercent)}%;"></div>
                    </div>
                    ${intimacy < 5000 ? `距离下一里程碑：${nextMilestone - intimacy}` : '已达到最高等级！'}
                </div>
                <div class="cat-status" style="color: #6c757d; font-size: 12px;">
                    ${catData && catData.lastGift ? `上次礼物：${catData.lastGift}` : '还没有收到过礼物'}
                </div>
            `;
        }

        function feedCat() {
            if (!gameData.selectedCat) {
                showAlert('请先选择一只猫咪！', '猫咪系统', '🐱');
                return;
            }

            if (gameData.madeTeas.length === 0) {
                showAlert('没有茶饮可以喂给猫咪！请先制作一些茶饮。', '茶饮不足', '🍵');
                return;
            }

            const cat = gameData.cats[gameData.selectedCat];
            const beforeIntimacy = cat.intimacy;
            
            // 消耗一个茶饮
            const tea = gameData.madeTeas.shift();
            
            // 增加亲密度（按照5000满级设计）
            const intimacyGain = Math.floor(Math.random() * 50) + 25; // 25-74点亲密度
            cat.intimacy = Math.min(5000, cat.intimacy + intimacyGain);
            
            // 同步到旧结构保证兼容性
            if (gameData.cats.intimacy) {
                gameData.cats.intimacy[gameData.selectedCat] = cat.intimacy;
            }
            
            addDebugLog(`喂食${gameData.selectedCat}：消耗了${tea.name}，亲密度 ${beforeIntimacy} → ${cat.intimacy} (+${intimacyGain})`);
            
            // 检查是否达到里程碑并给予礼物
            const milestones = [500, 1500, 3000, 5000];
            const reachedMilestone = milestones.find(milestone =>
                beforeIntimacy < milestone && cat.intimacy >= milestone
            );

            if (reachedMilestone) {
                // 达到里程碑，给予特殊礼物
                let gift = '';
                let giftDescription = '';

                if (reachedMilestone === 500) {
                    gift = '小鱼干';
                    gameData.toppings['小鱼干'] = (gameData.toppings['小鱼干'] || 0) + 3;
                    giftDescription = '3个小鱼干';
                } else if (reachedMilestone === 1500) {
                    gift = '金币';
                    const goldReward = 50;
                    gameData.funds += goldReward;
                    giftDescription = `${goldReward}金币`;
                } else if (reachedMilestone === 3000) {
                    gift = '稀有种子 + 稻香村解锁';
                    const rareSeeds = ['五味子', '洛神花', '玫瑰花'];
                    const randomSeed = rareSeeds[Math.floor(Math.random() * rareSeeds.length)];
                    gameData.seeds[randomSeed] = (gameData.seeds[randomSeed] || 0) + 2;
                    giftDescription = `2个${randomSeed}种子`;

                    // 解锁稻香村
                    if (!gameData.riceVillage) {
                        gameData.riceVillage = {
                            unlocked: true,
                            maxIntimacyCats: []
                        };
                    }

                    // 添加到满级猫咪列表
                    if (!gameData.riceVillage.maxIntimacyCats.includes(catName)) {
                        gameData.riceVillage.maxIntimacyCats.push(catName);
                        addDebugLog(`🏮 ${catName}达到3000亲密度，解锁稻香村！`);

                        // 显示稻香村解锁提示
                        setTimeout(() => {
                            const unlockContent = `
                                <div style="text-align: center; line-height: 1.6;">
                                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">🏮 重大发现！</h3>
                                    <div style="margin-bottom: 15px; padding: 12px; background: #f0f9ff; border: 1px inset #c0c0c0;">
                                        <div style="font-weight: bold; color: #d2691e; margin-bottom: 8px;">${catName} 亲密度达到3000！</div>
                                        <div style="color: #1e40af; font-weight: bold; margin-bottom: 8px;">🏮 解锁稻香村！</div>
                                        <div style="color: #666; font-size: 12px;">与猫咪伙伴一起踏上冒险之旅</div>
                                    </div>
                                </div>
                            `;
                            showWin95Modal('稻香村解锁', unlockContent, '🏮');
                            updateRiceVillageDisplay();
                        }, 2000);
                    }
                } else if (reachedMilestone === 5000) {
                    gift = '终极礼物';
                    gameData.funds += 100;
                    gameData.toppings['小鱼干'] = (gameData.toppings['小鱼干'] || 0) + 10;
                    giftDescription = '100金币 + 10个小鱼干';
                }

                cat.lastGift = giftDescription;
                document.getElementById('current-funds').textContent = gameData.funds + ' 金币';
                addDebugLog(`🎁 ${gameData.selectedCat}达到${reachedMilestone}亲密度里程碑！赠送了：${giftDescription}`);

                showWin95Modal('猫咪里程碑', `<div style="text-align: center; line-height: 1.6;"><div style="font-size: 12px; margin-bottom: 10px;">🎉 ${gameData.selectedCat} 达到 ${reachedMilestone} 亲密度里程碑！</div><div style="color: #d4af37; font-weight: bold;">获得奖励：${giftDescription}</div></div>`, '🎁');
            }
            
            renderSelectedCat();
            renderCatsTable(); // 重新渲染猫咪表格
            updateAllInventoryDisplay();
            saveGameDataToDatabase(); // 立即保存数据
        }

        function petCat() {
            if (!gameData.selectedCat) {
                showAlert('请先选择一只猫咪！', '猫咪系统', '🐱');
                return;
            }

            const cat = gameData.cats[gameData.selectedCat];
            const beforeIntimacy = cat.intimacy;
            
            // 撸猫增加少量亲密度（按照5000满级设计）
            const intimacyGain = Math.floor(Math.random() * 15) + 5; // 5-19点亲密度
            cat.intimacy = Math.min(5000, cat.intimacy + intimacyGain);
            
            // 同步到旧结构保证兼容性
            if (gameData.cats.intimacy) {
                gameData.cats.intimacy[gameData.selectedCat] = cat.intimacy;
            }
            
            addDebugLog(`撸猫${gameData.selectedCat}：亲密度 ${beforeIntimacy} → ${cat.intimacy} (+${intimacyGain})`);
            
            const reactions = ['喵~', '呼噜呼噜~', '舒服~', '再来一次！', '开心~'];
            const reaction = reactions[Math.floor(Math.random() * reactions.length)];
            showAlert(`${gameData.selectedCat}：${reaction}`, '猫咪反应', '🐱');
            
            renderSelectedCat();
            renderCatsTable(); // 重新渲染猫咪表格
            updateAllInventoryDisplay();
            saveGameDataToDatabase(); // 立即保存数据
        }

        // 下拉菜单控制函数
        function toggleDropdown(dropdownId) {
            const dropdown = document.getElementById(dropdownId);
            const isVisible = dropdown.classList.contains('show');

            // 先关闭所有下拉菜单
            closeAllDropdowns();

            // 如果当前菜单不是显示状态，则显示它
            if (!isVisible) {
                dropdown.classList.add('show');
            }
        }

        function closeDropdown(dropdownId) {
            const dropdown = document.getElementById(dropdownId);
            dropdown.classList.remove('show');
        }

        function closeAllDropdowns() {
            const dropdowns = document.querySelectorAll('.dropdown-content');
            dropdowns.forEach(dropdown => {
                dropdown.classList.remove('show');
            });
        }

        // 点击页面其他地方时关闭下拉菜单
        document.addEventListener('click', function(event) {
            const isDropdownButton = event.target.closest('.menu-btn');
            const isDropdownContent = event.target.closest('.dropdown-content');

            if (!isDropdownButton && !isDropdownContent) {
                closeAllDropdowns();
            }
        });

        // 存档管理系统

        // GitHub Pages版本：立即保存到本地存储+云端
        function saveToDatabaseNow() {
            addDebugLog('🎯 用户手动触发立即保存...');
            saveGameDataToDatabase();

            // 检查云端存档状态
            const cloudStatus = cloudSaveConfig.githubToken && cloudSaveConfig.gistId ? '已同步到云端' : '仅保存到本地';
            showAlert(`游戏数据已保存到本地存储，${cloudStatus}`, '保存完成', '💾');
        }

        // 实时记录顾客访问到数据库
        function recordCustomerVisitToDatabase(customerName, customerType, teaServed, toppingsServed, totalPrice) {
            const visitData = {
                customerName: customerName,
                customerType: customerType,
                teaServed: teaServed,
                toppingsServed: toppingsServed,
                totalPrice: totalPrice
            };

            addDebugLog(`🎯 实时记录顾客访问：${customerName} (${customerType})`);

            fetch('http://localhost:5002/api/customer/visit', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(visitData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    addDebugLog(`✅ 顾客访问记录成功：${customerName} 总访问${data.totalVisits}次`);

                    // 更新本地数据
                    if (customerType === 'vip') {
                        if (!gameData.customerVisits) gameData.customerVisits = {};
                        gameData.customerVisits[customerName] = data.totalVisits;

                        // 同步更新customers表
                        if (gameData.customers && gameData.customers[customerName]) {
                            gameData.customers[customerName].visits = data.totalVisits;
                        }

                        // 更新顾客管理表显示
                        renderCustomersTable();
                    }
                } else {
                    addDebugLog(`❌ 顾客访问记录失败：${data.error}`);
                }
            })
            .catch(error => {
                addDebugLog(`❌ 顾客访问记录网络错误：${error.message}`);
            });
        }

        // 开始后山打猎
        function startHunting() {
            if (!gameData.huntingSystem.backMountain.unlocked || gameData.huntingSystem.backMountain.isHunting) return;

            gameData.huntingSystem.backMountain.isHunting = true;
            gameData.huntingSystem.backMountain.huntStartTime = Date.now();

            addDebugLog(`🏹 开始后山打猎... 持续时间：${gameData.huntingSystem.backMountain.huntDuration}毫秒`);
            updateHuntingDisplay();

            // 设置定时器
            setTimeout(() => {
                addDebugLog('⏰ 后山打猎定时器触发');
                if (gameData.huntingSystem.backMountain.isHunting) {
                    addDebugLog('⏰ 定时器检查：后山打猎状态为true，调用completeHunting');
                    completeHunting('backMountain');
                } else {
                    addDebugLog('⏰ 定时器检查：后山打猎状态为false，跳过');
                }
            }, gameData.huntingSystem.backMountain.huntDuration);
        }

        // 开始山洞打猎
        function startCaveHunting() {
            if (!gameData.huntingSystem.cave.unlocked || gameData.huntingSystem.cave.isHunting) return;

            gameData.huntingSystem.cave.isHunting = true;
            gameData.huntingSystem.cave.huntStartTime = Date.now();

            addDebugLog(`🏔️ 开始山洞打猎... 持续时间：${gameData.huntingSystem.cave.huntDuration}毫秒`);
            updateCaveHuntingDisplay();

            // 设置定时器
            setTimeout(() => {
                addDebugLog('⏰ 山洞打猎定时器触发');
                if (gameData.huntingSystem.cave.isHunting) {
                    addDebugLog('⏰ 定时器检查：山洞打猎状态为true，调用completeHunting');
                    completeHunting('cave');
                } else {
                    addDebugLog('⏰ 定时器检查：山洞打猎状态为false，跳过');
                }
            }, gameData.huntingSystem.cave.huntDuration);
        }

        // 完成打猎
        function completeHunting(location = 'backMountain') {
            const huntingData = gameData.huntingSystem[location];

            if (!huntingData.isHunting) {
                addDebugLog(`⚠️ completeHunting被调用但${location}打猎状态为false`);
                return;
            }

            addDebugLog(`🎯 开始完成${location}打猎流程...`);
            huntingData.isHunting = false;
            huntingData.huntCount++;

            // 确定猎物池
            const huntPool = huntingData.huntCount >= 50 ?
                [...huntingData.huntResults.basic, ...huntingData.huntResults.advanced] :
                huntingData.huntResults.basic;

            addDebugLog(`🎯 ${location}使用猎物池：${huntPool.map(item => item.name).join(', ')}`);

            // 随机选择猎物
            const random = Math.random();
            addDebugLog(`🎯 随机数：${random}`);
            let cumulativeChance = 0;
            let huntResult = null;

            for (const item of huntPool) {
                cumulativeChance += item.chance;
                addDebugLog(`🎯 检查 ${item.name}：累积概率 ${cumulativeChance}，随机数 ${random}`);
                if (random <= cumulativeChance) {
                    huntResult = item;
                    addDebugLog(`🎯 选中猎物：${item.name}`);
                    break;
                }
            }

            if (!huntResult) {
                huntResult = huntPool[huntPool.length - 1]; // 备选
                addDebugLog(`🎯 使用备选猎物：${huntResult.name}`);
            }

            // 添加到库存
            addDebugLog(`🎯 准备添加到库存：${huntResult.name}`);
            if (!gameData.materials) {
                gameData.materials = {};
                addDebugLog(`🎯 初始化materials对象`);
            }
            if (!gameData.treasures) {
                gameData.treasures = {};
                addDebugLog(`🎯 初始化treasures对象`);
            }
            // 处理不同类型的打猎结果
            let resultMessage = '';
            let specialAction = '';

            if (huntResult.name === '金币') {
                // 直接获得金币
                const goldAmount = huntResult.value || 15;
                gameData.funds += goldAmount;
                resultMessage = `获得：${goldAmount}金币`;
                addDebugLog(`🎯 打猎获得金币：+${goldAmount}，当前资金：${gameData.funds}`);
            } else if (huntResult.name === '地图') {
                // 解锁山洞打猎
                if (!gameData.treasures[huntResult.name]) {
                    gameData.treasures[huntResult.name] = 0;
                }
                gameData.treasures[huntResult.name]++;

                if (!gameData.huntingSystem.cave.unlocked) {
                    gameData.huntingSystem.cave.unlocked = true;
                    specialAction = 'unlock_cave';
                    resultMessage = `获得：神秘地图 - 解锁山洞打猎！`;
                    addDebugLog(`🗺️ 获得地图，解锁山洞打猎功能！`);
                } else {
                    resultMessage = `获得：地图碎片`;
                    addDebugLog(`🗺️ 获得额外地图碎片`);
                }
            } else if (['簪子', '梳子', '石头', '花朵'].includes(huntResult.name)) {
                // 特殊物品存储到treasures
                if (!gameData.treasures[huntResult.name]) {
                    gameData.treasures[huntResult.name] = 0;
                }
                const oldCount = gameData.treasures[huntResult.name];
                gameData.treasures[huntResult.name]++;
                const newCount = gameData.treasures[huntResult.name];
                resultMessage = `获得：${huntResult.name}`;
                addDebugLog(`🎯 打猎获得特殊物品：${huntResult.name} (${oldCount} → ${newCount})`);
            } else {
                // 普通材料存储到materials
                if (!gameData.materials[huntResult.name]) {
                    gameData.materials[huntResult.name] = 0;
                }
                const oldCount = gameData.materials[huntResult.name];
                gameData.materials[huntResult.name]++;
                const newCount = gameData.materials[huntResult.name];
                resultMessage = `获得：${huntResult.name}`;
                addDebugLog(`🎯 打猎获得材料：${huntResult.name} (${oldCount} → ${newCount})`);
            }

            // 检查首次获得配方解锁
            if (huntResult.firstTimeRecipe && !gameData.teaRecipes[huntResult.firstTimeRecipe]) {
                gameData.teaRecipes[huntResult.firstTimeRecipe] = ['浆果'];
                addDebugLog(`🎉 首次获得${huntResult.name}，解锁配方：${huntResult.firstTimeRecipe}！`);

                const unlockContent = `
                    <div style="text-align: center; line-height: 1.6;">
                        <h3 style="color: #0040c0; margin: 0 0 15px 0;">🎉 新配方解锁！</h3>
                        <div style="margin-bottom: 15px; padding: 12px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                            <div style="color: #666; margin-bottom: 8px;">首次猎到 ${huntResult.name}</div>
                            <div style="font-weight: bold; color: #d2691e;">解锁配方：${huntResult.firstTimeRecipe}</div>
                        </div>
                    </div>
                `;
                showWin95Modal('打猎配方解锁', unlockContent, '🎯');
            }

            // 显示打猎结果弹窗
            addDebugLog(`🎯 准备显示打猎结果弹窗`);
            const locationName = location === 'backMountain' ? '后山' : '山洞';
            const locationIcon = location === 'backMountain' ? '🎯' : '🏔️';

            let huntResultContent = `
                <div style="text-align: center; line-height: 1.6;">
                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">${locationIcon} ${locationName}打猎成功！</h3>
                    <div style="margin-bottom: 15px; padding: 12px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                        <div style="font-size: 18px; font-weight: bold; color: #d2691e; margin-bottom: 8px;">${resultMessage}</div>
                        <div style="color: #666; font-size: 14px;">${locationName}打猎次数：${huntingData.huntCount}</div>
                        ${huntingData.huntCount >= 50 ? '<div style="color: #22c55e; font-size: 12px;">已解锁高级猎物</div>' : ''}
                    </div>
                </div>
            `;

            // 如果解锁了山洞，显示特殊提示
            if (specialAction === 'unlock_cave') {
                huntResultContent = `
                    <div style="text-align: center; line-height: 1.6;">
                        <h3 style="color: #0040c0; margin: 0 0 15px 0;">🗺️ 重大发现！</h3>
                        <div style="margin-bottom: 15px; padding: 12px; background: #f0f9ff; border: 1px inset #c0c0c0;">
                            <div style="font-size: 18px; font-weight: bold; color: #d2691e; margin-bottom: 8px;">获得：神秘地图</div>
                            <div style="color: #1e40af; font-weight: bold; margin-bottom: 8px;">🏔️ 解锁山洞打猎功能！</div>
                            <div style="color: #666; font-size: 12px;">山洞打猎时间：20秒，可获得珍贵的银耳</div>
                        </div>
                    </div>
                `;
            }

            showWin95Modal('打猎结果', huntResultContent, '🎯');
            addDebugLog(`🎯 打猎结果弹窗已显示`);

            // 更新状态显示
            const huntingStatus = document.getElementById('hunting-status');
            if (huntingStatus) {
                huntingStatus.innerHTML = `<div class="alert alert-success">🎯 打猎成功！获得：${huntResult.name}</div>`;
                setTimeout(() => {
                    updateHuntingDisplay();
                }, 3000);
            }

            addDebugLog(`🎯 开始更新界面和保存数据`);
            updateHuntingDisplay();
            updateAllInventoryDisplay();
            saveGameDataToDatabase();
            addDebugLog(`🎯 打猎完成流程结束`);
        }

        // 调试函数：检查顾客数据和配方解锁
        function debugCustomerUnlock() {
            addDebugLog('=== 顾客数据调试 ===');
            addDebugLog(`customerVisits: ${JSON.stringify(gameData.customerVisits)}`);
            addDebugLog(`customers: ${JSON.stringify(gameData.customers)}`);
            addDebugLog(`已解锁配方: ${Object.keys(gameData.teaRecipes).join(', ')}`);

            // 手动检查池九信和狸怒的解锁
            if (gameData.customerVisits['池九信'] >= 2) {
                addDebugLog('🔍 手动检查池九信配方解锁...');
                checkRecipeUnlock('池九信');
            }
            if (gameData.customerVisits['狸怒'] >= 1) {
                addDebugLog('🔍 手动检查狸怒配方解锁...');
                checkRecipeUnlock('狸怒');
            }

            addDebugLog('=== 调试完成 ===');
        }

        // 测试烤肉架解锁
        function testGrillUnlock() {
            addDebugLog('🧪 测试姬别情烤肉架解锁...');

            // 设置姬别情访问次数为6
            if (!gameData.customerVisits) gameData.customerVisits = {};
            gameData.customerVisits['姬别情'] = 6;

            if (gameData.customers && gameData.customers['姬别情']) {
                gameData.customers['姬别情'].visits = 6;
            }

            // 直接解锁功能（绕过检查）
            gameData.grillSystem.unlocked = true;
            gameData.huntingSystem.backMountain.unlocked = true;

            addDebugLog(`🔥 强制解锁烤肉架和打猎功能！`);

            // 显示解锁提示
            const unlockContent = `
                <div style="text-align: center; line-height: 1.6;">
                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">🔥 茶铺升级！</h3>
                    <div style="margin-bottom: 15px; padding: 12px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                        <div style="color: #666; margin-bottom: 8px;">姬别情 6次访问达成</div>
                        <div style="font-weight: bold; color: #d2691e; margin-bottom: 8px;">🔥 解锁烤肉架功能</div>
                        <div style="font-weight: bold; color: #228b22;">🏹 解锁后山打猎功能</div>
                    </div>
                    <div style="color: #888; font-size: 12px; line-height: 1.4;">
                        现在可以为顾客提供烤肉服务<br>
                        点击打猎按钮获取肉类和其他食材<br>
                        首次猎到浆果可解锁浆果汁配方
                    </div>
                </div>
            `;
            showWin95Modal('茶铺功能升级', unlockContent, '🔥');

            // 更新界面显示
            updateGrillAndHuntingDisplay();

            // 更新显示
            renderCustomersTable();
            saveGameDataToDatabase();

            addDebugLog('✅ 测试完成，姬别情访问次数设为6次');
        }

        function initSaveSlots() {
            // 初始化存档槽位显示
            updateSaveSlotDisplay();
        }

        function updateSaveSlotDisplay() {
            for (let i = 1; i <= 4; i++) {
                const timeElement = document.getElementById(`save-time-${i}`);
                if (timeElement) {
                    const saveData = localStorage.getItem(`teaGameSave_${i}`);
                    if (saveData) {
                        try {
                            const data = JSON.parse(saveData);
                            timeElement.textContent = new Date(data.timestamp).toLocaleString();
                        } catch (error) {
                            timeElement.textContent = '数据损坏';
                        }
                    } else {
                        if (i === 1) {
                            timeElement.textContent = '自动存档';
                        } else {
                            timeElement.textContent = '空槽位';
                        }
                    }
                }
            }
        }

        function handleSaveSlot(slotNumber) {
            if (slotNumber === 1) {
                // 槽位1是自动存档，只能加载
                showSaveSlotMenu(1, true); // 传入true表示只读模式
                return;
            }

            const saveData = localStorage.getItem(`teaGameSave_${slotNumber}`);

            if (saveData) {
                // 已有存档，显示选择菜单
                showSaveSlotMenu(slotNumber, false);
            } else {
                // 空槽位，显示保存/新建选项
                showEmptySlotMenu(slotNumber);
            }
        }

        function showSaveSlotMenu(slotNumber, isReadOnly = false) {
            const saveData = localStorage.getItem(`teaGameSave_${slotNumber}`);
            const data = JSON.parse(saveData);
            const saveTime = new Date(data.timestamp).toLocaleString();

            let buttonsHtml = '';
            if (isReadOnly) {
                // 自动存档槽位，只能加载
                buttonsHtml = `
                    <button class="action-btn" onclick="loadSaveSlot(${slotNumber}); closeWin95Modal();">加载存档</button>
                `;
            } else {
                // 手动存档槽位，可以加载、保存、删除
                buttonsHtml = `
                    <button class="action-btn" onclick="loadSaveSlot(${slotNumber}); closeWin95Modal();">加载存档</button>
                    <button class="action-btn" onclick="saveToSlot(${slotNumber}); closeWin95Modal();" style="background: #22c55e;">保存进度</button>
                    <button class="action-btn" onclick="deleteSaveSlot(${slotNumber}); closeWin95Modal();" style="background: #ef4444;">删除存档</button>
                `;
            }

            const menuContent = `
                <div style="text-align: center; line-height: 1.6;">
                    <div style="font-size: 14px; font-weight: 600; margin-bottom: 10px;">槽位${slotNumber}${isReadOnly ? ' - 自动存档' : ''}</div>
                    <div style="color: #666; margin-bottom: 15px;">保存时间：${saveTime}</div>
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                        ${buttonsHtml}
                    </div>
                </div>
            `;

            showWin95Modal('存档管理', menuContent, '💾');
        }

        function showEmptySlotMenu(slotNumber) {
            const menuContent = `
                <div style="text-align: center; line-height: 1.6;">
                    <div style="font-size: 14px; font-weight: 600; margin-bottom: 10px;">槽位${slotNumber} - 空槽位</div>
                    <div style="color: #666; margin-bottom: 15px;">选择操作：</div>
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                        <button class="action-btn" onclick="saveToSlot(${slotNumber}); closeWin95Modal();" style="background: #22c55e;">保存当前进度</button>
                        <button class="action-btn" onclick="createNewSave(${slotNumber}); closeWin95Modal();" style="background: #f59e0b;">新建存档</button>
                    </div>
                    <div style="margin-top: 10px; font-size: 10px; color: #999;">
                        保存当前进度：保存现在的游戏状态<br>
                        新建存档：清空进度重新开始
                    </div>
                </div>
            `;

            showWin95Modal('存档管理', menuContent, '💾');
        }

        function createNewSave(slotNumber) {
            // 清空当前游戏数据
            resetGameDataSilent();

            // 保存到指定槽位
            saveToSlot(slotNumber);

            addDebugLog(`已在槽位${slotNumber}创建新存档`);
            showAlert(`已在槽位${slotNumber}创建新存档`, '新建成功', '💾');
        }

        function saveToSlot(slotNumber) {
            const gameState = {
                timestamp: new Date().toISOString(),
                funds: gameData.funds,
                plots: gameData.plots,
                inventory: gameData.inventory,
                seeds: gameData.seeds,
                madeTeas: gameData.madeTeas,
                toppings: gameData.toppings,
                stoves: gameData.stoves,
                processingBoards: gameData.processingBoards,
                customer: gameData.customer,
                cats: gameData.cats,
                customers: gameData.customers,
                servedCustomers: gameData.servedCustomers,
                lastCustomerTime: gameData.lastCustomerTime,
                currentDay: gameData.currentDay,
                seasonDay: gameData.seasonDay,
                season: gameData.season,
                weather: gameData.weather,
                currentSeason: gameData.currentSeason,
                currentWeather: gameData.currentWeather,
                lastDayChange: gameData.lastDayChange,
                selectedCat: gameData.selectedCat,
                customerVisits: gameData.customerVisits,
                teaRecipes: gameData.teaRecipes
            };

            localStorage.setItem(`teaGameSave_${slotNumber}`, JSON.stringify(gameState));
            updateSaveSlotDisplay();

            addDebugLog(`游戏已保存到槽位${slotNumber}`);
            showAlert(`游戏已保存到槽位${slotNumber}`, '保存成功', '💾');
        }

        function loadSaveSlot(slotNumber) {
            const saveData = localStorage.getItem(`teaGameSave_${slotNumber}`);

            if (!saveData) {
                showAlert(`槽位${slotNumber}为空！`, '加载失败', '❌');
                return;
            }

            try {
                const gameState = JSON.parse(saveData);
                Object.assign(gameData, gameState);

                // 更新所有显示
                renderFarmGrid();
                renderWorkspaces();
                updateAllInventoryDisplay();
                updateAllFundsDisplay();
                updateDebugDisplay();
                updateWeatherAndSeasonDisplay();

                addDebugLog(`已从槽位${slotNumber}加载存档`);
                showAlert(`已从槽位${slotNumber}加载存档`, '加载成功', '💾');
            } catch (error) {
                showAlert(`槽位${slotNumber}数据损坏！`, '加载失败', '❌');
                addDebugLog(`槽位${slotNumber}数据解析失败: ${error.message}`);
            }
        }

        function deleteSaveSlot(slotNumber) {
            if (slotNumber === 1) {
                showAlert('不能删除自动存档槽位！', '删除失败', '❌');
                return;
            }

            showConfirm(
                `确定要删除槽位${slotNumber}的存档吗？<br><br><strong style="color: red;">此操作不可撤销！</strong>`,
                '删除存档',
                () => {
                    localStorage.removeItem(`teaGameSave_${slotNumber}`);
                    updateSaveSlotDisplay();
                    addDebugLog(`已删除槽位${slotNumber}的存档`);
                    showAlert(`已删除槽位${slotNumber}的存档`, '删除成功', '🗑️');
                }
            );
        }

        function resetGameDataSilent() {
            // 静默重置游戏数据（不显示确认对话框）
            gameData.funds = 1000;
            gameData.currentDay = 1;
            gameData.seasonDay = 1;
            gameData.season = 0;
            gameData.weather = 0;
            gameData.currentSeason = "春天";
            gameData.currentWeather = "晴天";
            gameData.lastDayChange = Date.now();
            gameData.servedCustomers = 0;
            gameData.lastCustomerTime = 0;

            // 重置所有数组和对象
            gameData.plots.forEach(plot => {
                plot.state = 'empty';
                plot.plantType = null;
                plot.plantTime = null;
                plot.moisture = 50;
                plot.fertility = 50;
            });

            gameData.inventory = {};
            gameData.seeds = {};
            gameData.madeTeas = [];
            gameData.toppings = {};
            gameData.customer = { active: false };
            gameData.cats = {};
            gameData.customers = {};
            gameData.customerVisits = {};
            gameData.selectedCat = null;

            // 重置工作台状态
            gameData.stoves.forEach(stove => {
                stove.state = 'idle';
                stove.recipe = null;
                stove.startTime = null;
                stove.duration = null;
            });

            gameData.processingBoards.forEach(board => {
                board.state = 'idle';
                board.recipe = null;
                board.startTime = null;
                board.duration = null;
            });

            // 重新初始化基础配方
            gameData.teaRecipes = {
                '五味子饮': ['五味子'],
                '柠檬茶': ['柠檬']
            };

            // 更新所有显示
            renderFarmGrid();
            renderWorkspaces();
            updateAllInventoryDisplay();
            updateAllFundsDisplay();
            updateDebugDisplay();
        }

        // 检查特殊功能解锁
        function checkSpecialFeatureUnlock(customerName) {
            if (!gameData.customerVisits || !gameData.customers) return;

            const visitCount = gameData.customerVisits[customerName] || 0;

            // 姬别情6次访问解锁烤肉架
            if (customerName === '姬别情' && visitCount >= 6 && !gameData.grillSystem.unlocked) {
                gameData.grillSystem.unlocked = true;
                gameData.huntingSystem.backMountain.unlocked = true;

                addDebugLog(`🔥 姬别情6次访问，解锁烤肉架和打猎功能！`);

                const unlockContent = `
                    <div style="text-align: center; line-height: 1.6;">
                        <h3 style="color: #0040c0; margin: 0 0 15px 0;">🔥 茶铺升级！</h3>
                        <div style="margin-bottom: 15px; padding: 12px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                            <div style="color: #666; margin-bottom: 8px;">姬别情 6次访问达成</div>
                            <div style="font-weight: bold; color: #d2691e; margin-bottom: 8px;">🔥 解锁烤肉架功能</div>
                            <div style="font-weight: bold; color: #228b22;">🏹 解锁后山打猎功能</div>
                        </div>
                        <div style="color: #888; font-size: 12px; line-height: 1.4;">
                            现在可以为顾客提供烤肉服务<br>
                            点击打猎按钮获取肉类和其他食材<br>
                            首次猎到浆果可解锁浆果汁配方
                        </div>
                    </div>
                `;
                showWin95Modal('茶铺功能升级', unlockContent, '🔥');

                // 更新界面显示
                updateGrillAndHuntingDisplay();
            }
        }

        // 更新烤肉架和打猎显示
        function updateGrillAndHuntingDisplay() {
            const grillSection = document.getElementById('grill-section');
            const huntingSection = document.getElementById('hunting-section');
            const caveHuntingSection = document.getElementById('cave-hunting-section');

            if (gameData.grillSystem.unlocked) {
                grillSection.style.display = 'block';
                renderGrillTable();
            }

            if (gameData.huntingSystem.backMountain.unlocked) {
                huntingSection.style.display = 'block';
                updateHuntingDisplay();
            }

            if (gameData.huntingSystem.cave.unlocked && caveHuntingSection) {
                caveHuntingSection.style.display = 'block';
                updateCaveHuntingDisplay();
            }
        }

        // 渲染烤肉架表格
        function renderGrillTable() {
            const grillTable = document.getElementById('grill-table');
            if (!grillTable) return;

            grillTable.innerHTML = `
                <tr>
                    <td>烤肉架 #1</td>
                    <td id="grill-recipe">${gameData.grillSystem.currentRecipe || '空闲'}</td>
                    <td id="grill-progress">
                        ${gameData.grillSystem.isGrilling ?
                            `<div class="progress-bar">
                                <div class="progress-fill" id="grill-progress-fill" style="width: 0%"></div>
                            </div>` :
                            '等待中'
                        }
                    </td>
                    <td>
                        <button class="action-btn" onclick="showGrillMenu()"
                                ${gameData.grillSystem.isGrilling ? 'disabled' : ''}>
                            🔥 开始烤制
                        </button>
                    </td>
                </tr>
            `;
        }

        // 显示烤肉架菜单
        function showGrillMenu() {
            if (!gameData.grillSystem.unlocked || gameData.grillSystem.isGrilling) return;

            // 获取可用的烤制配方
            const availableRecipes = Object.keys(gameData.grillSystem.recipes).filter(recipe => {
                const recipeData = gameData.grillSystem.recipes[recipe];
                return recipeData.ingredients.every(ingredient =>
                    gameData.materials && gameData.materials[ingredient] > 0
                );
            });

            if (availableRecipes.length === 0) {
                showAlert('没有可烤制的肉类材料！请先打猎并分解动物获得肉类。', '烤制失败', '🔥');
                return;
            }

            // 创建烤制选择弹窗
            const grillContent = `
                <div style="text-align: center; line-height: 1.6;">
                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">🔥 选择烤制配方</h3>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${availableRecipes.map(recipe => {
                            const recipeData = gameData.grillSystem.recipes[recipe];
                            const ingredients = recipeData.ingredients.join(' + ');
                            const cookTimeSeconds = Math.round(recipeData.cookTime / 1000);
                            const availableCount = Math.min(...recipeData.ingredients.map(ing => gameData.materials[ing] || 0));

                            return `
                                <div style="margin-bottom: 10px; padding: 10px; background: #f0f0f0; border: 1px inset #c0c0c0; cursor: pointer;"
                                     onclick="startGrilling('${recipe}'); closeModal();">
                                    <div style="font-weight: bold; color: #d2691e;">${recipe}</div>
                                    <div style="font-size: 12px; color: #666; margin: 4px 0;">需要: ${ingredients}</div>
                                    <div style="font-size: 12px; color: #666; margin: 4px 0;">烤制时间: ${cookTimeSeconds}秒</div>
                                    <div style="font-size: 12px; color: #666; margin: 4px 0;">售价: ${recipeData.price}金币</div>
                                    <div style="font-size: 12px; color: #22c55e;">可烤制: ${availableCount}次</div>
                                    <div style="font-size: 11px; color: #999; margin-top: 4px;">${recipeData.description}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;

            showWin95Modal('烤肉架', grillContent, '🔥');
        }

        // 开始烤制
        function startGrilling(recipeName) {
            if (!gameData.grillSystem.unlocked || gameData.grillSystem.isGrilling) return;

            const recipe = gameData.grillSystem.recipes[recipeName];
            if (!recipe) return;

            // 检查材料是否足够
            const hasEnoughMaterials = recipe.ingredients.every(ingredient =>
                gameData.materials && gameData.materials[ingredient] > 0
            );

            if (!hasEnoughMaterials) {
                showAlert('材料不足！', '烤制失败', '🔥');
                return;
            }

            // 消耗材料
            addDebugLog(`🔥 开始烤制${recipeName}，消耗材料：`);
            recipe.ingredients.forEach(ingredient => {
                const beforeCount = gameData.materials[ingredient];
                gameData.materials[ingredient] = Math.max(0, beforeCount - 1);
                const afterCount = gameData.materials[ingredient];
                addDebugLog(`  - ${ingredient}: ${beforeCount} → ${afterCount} (-1)`);
            });

            // 设置烤制状态
            gameData.grillSystem.isGrilling = true;
            gameData.grillSystem.grillStartTime = Date.now();
            gameData.grillSystem.grillDuration = recipe.cookTime;
            gameData.grillSystem.currentRecipe = recipeName;

            addDebugLog(`🔥 开始烤制${recipeName}，预计${Math.round(recipe.cookTime / 1000)}秒完成`);

            // 更新显示
            renderGrillTable();
            updateAllInventoryDisplay();

            // 设置定时器
            setTimeout(() => {
                if (gameData.grillSystem.isGrilling && gameData.grillSystem.currentRecipe === recipeName) {
                    completeGrilling();
                }
            }, recipe.cookTime);
        }

        // 完成烤制
        function completeGrilling() {
            if (!gameData.grillSystem.isGrilling) return;

            const recipeName = gameData.grillSystem.currentRecipe;
            const recipe = gameData.grillSystem.recipes[recipeName];

            addDebugLog(`🔥 烤制完成：${recipeName}`);

            // 重置烤制状态
            gameData.grillSystem.isGrilling = false;
            gameData.grillSystem.grillStartTime = 0;
            gameData.grillSystem.grillDuration = 0;
            gameData.grillSystem.currentRecipe = null;
            gameData.grillSystem.currentProduct = recipeName;

            // 显示烤制完成和售卖选择
            showGrillSellOptions(recipeName, recipe);

            // 更新显示
            renderGrillTable();
            updateAllInventoryDisplay();
            saveGameDataToDatabase();
        }

        // 显示售卖选择
        function showGrillSellOptions(productName, recipe) {
            const sellContent = `
                <div style="text-align: center; line-height: 1.6;">
                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">🔥 烤制完成！</h3>
                    <div style="margin-bottom: 15px; padding: 12px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                        <div style="font-size: 18px; font-weight: bold; color: #d2691e; margin-bottom: 8px;">${productName}</div>
                        <div style="color: #666; font-size: 14px; margin-bottom: 8px;">${recipe.description}</div>
                        <div style="color: #22c55e; font-weight: bold;">基础价格: ${recipe.price}金币</div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <div style="font-weight: bold; margin-bottom: 10px;">选择售卖方式：</div>
                        <div style="margin-bottom: 8px;">
                            <button style="width: 100%; padding: 8px; margin-bottom: 5px; background: #e5e7eb; border: 1px solid #d1d5db; cursor: pointer;"
                                    onclick="sellGrilledFood('${productName}', ${recipe.price}, 'direct'); closeModal();">
                                💰 直接售卖 (${recipe.price}金币)
                            </button>
                        </div>
                        <div>
                            <button style="width: 100%; padding: 8px; background: #dbeafe; border: 1px solid #93c5fd; cursor: pointer;"
                                    onclick="sellGrilledFood('${productName}', ${Math.round(recipe.price * 1.2)}, 'customer'); closeModal();">
                                🍽️ 等待顾客点餐 (${Math.round(recipe.price * 1.2)}金币+小费)
                            </button>
                        </div>
                    </div>
                </div>
            `;

            showWin95Modal('烤制完成', sellContent, '🔥');
        }

        // 售卖烤制食品
        function sellGrilledFood(productName, price, sellType) {
            if (sellType === 'direct') {
                // 直接售卖获得金币
                gameData.funds += price;
                addDebugLog(`💰 直接售卖${productName}，获得${price}金币`);
                showAlert(`售出${productName}，获得${price}金币！`, '售卖成功', '💰');

                // 重置产品状态
                gameData.grillSystem.currentProduct = null;

                updateAllInventoryDisplay();
                saveGameDataToDatabase();

            } else if (sellType === 'customer') {
                // 添加到茶饮库存等待顾客点餐
                gameData.madeTeas.push({
                    name: productName,
                    temperature: '热食',
                    makeTime: new Date().toLocaleTimeString(),
                    type: 'grilled',
                    basePrice: price
                });

                addDebugLog(`🍽️ ${productName}已添加到库存，等待顾客点餐`);
                showAlert(`${productName}已准备好，等待顾客点餐！`, '准备完成', '🍽️');

                // 重置产品状态
                gameData.grillSystem.currentProduct = null;

                updateAllInventoryDisplay();
                saveGameDataToDatabase();
            }
        }

        // 更新烤制进度
        function updateGrillProgress() {
            if (!gameData.grillSystem.isGrilling) return;

            const elapsed = Date.now() - gameData.grillSystem.grillStartTime;
            const remaining = Math.max(0, gameData.grillSystem.grillDuration - elapsed);
            const progress = Math.min(100, (elapsed / gameData.grillSystem.grillDuration) * 100);

            // 更新进度条
            const progressFill = document.getElementById('grill-progress-fill');
            if (progressFill) {
                progressFill.style.width = `${progress}%`;
            }

            // 更新配方显示（显示剩余时间）
            const grillRecipe = document.getElementById('grill-recipe');
            if (grillRecipe) {
                const remainingSeconds = Math.ceil(remaining / 1000);
                grillRecipe.textContent = `${gameData.grillSystem.currentRecipe} (${remainingSeconds}秒)`;
            }

            // 检查是否完成
            if (remaining <= 0) {
                completeGrilling();
            }
        }

        // 关闭当前弹窗
        function closeModal() {
            // 关闭所有可能的弹窗
            const modals = document.querySelectorAll('.modal, .win95-modal');
            modals.forEach(modal => {
                if (modal.style.display === 'block' || modal.style.display === 'flex') {
                    modal.style.display = 'none';
                }
            });
        }

        // 更新后山打猎显示
        function updateHuntingDisplay() {
            const huntCount = document.getElementById('hunt-count');
            const advancedStatus = document.getElementById('advanced-hunt-status');
            const huntBtn = document.getElementById('hunt-btn');
            const huntingStatus = document.getElementById('hunting-status');

            const backMountain = gameData.huntingSystem.backMountain;

            if (huntCount) huntCount.textContent = backMountain.huntCount;

            if (advancedStatus) {
                if (backMountain.huntCount >= 50) {
                    advancedStatus.textContent = '已解锁';
                    advancedStatus.style.color = '#22c55e';
                } else {
                    advancedStatus.textContent = `需要${50 - backMountain.huntCount}次`;
                }
            }

            if (backMountain.isHunting) {
                const elapsed = Date.now() - backMountain.huntStartTime;
                const remaining = Math.max(0, backMountain.huntDuration - elapsed);

                if (remaining <= 0) {
                    addDebugLog('⏰ 后山打猎时间到，触发完成打猎');
                    completeHunting('backMountain');
                    return;
                }

                const seconds = Math.max(1, Math.ceil(remaining / 1000));

                if (huntBtn) {
                    huntBtn.disabled = true;
                    huntBtn.textContent = `🏹 打猎中... (${seconds}秒)`;
                }

                if (huntingStatus) {
                    huntingStatus.innerHTML = `<div class="alert alert-info">正在后山打猎... 剩余${seconds}秒</div>`;
                }
            } else {
                if (huntBtn) {
                    huntBtn.disabled = false;
                    huntBtn.textContent = '🏹 开始打猎 (15秒)';
                }

                if (huntingStatus) {
                    huntingStatus.innerHTML = '<div class="alert alert-secondary">准备打猎...</div>';
                }
            }
        }

        // 更新山洞打猎显示
        function updateCaveHuntingDisplay() {
            const caveHuntCount = document.getElementById('cave-hunt-count');
            const caveHuntBtn = document.getElementById('cave-hunt-btn');
            const caveHuntingStatus = document.getElementById('cave-hunting-status');

            const cave = gameData.huntingSystem.cave;

            if (caveHuntCount) caveHuntCount.textContent = cave.huntCount;

            if (cave.isHunting) {
                const elapsed = Date.now() - cave.huntStartTime;
                const remaining = Math.max(0, cave.huntDuration - elapsed);

                if (remaining <= 0) {
                    addDebugLog('⏰ 山洞打猎时间到，触发完成打猎');
                    completeHunting('cave');
                    return;
                }

                const seconds = Math.max(1, Math.ceil(remaining / 1000));

                if (caveHuntBtn) {
                    caveHuntBtn.disabled = true;
                    caveHuntBtn.textContent = `🏔️ 探索中... (${seconds}秒)`;
                }

                if (caveHuntingStatus) {
                    caveHuntingStatus.innerHTML = `<div class="alert alert-info">正在探索山洞... 剩余${seconds}秒</div>`;
                }
            } else {
                if (caveHuntBtn) {
                    caveHuntBtn.disabled = false;
                    caveHuntBtn.textContent = '🏔️ 探索山洞 (20秒)';
                }

                if (caveHuntingStatus) {
                    caveHuntingStatus.innerHTML = '<div class="alert alert-secondary">准备探索山洞...</div>';
                }
            }
        }

        // 检查人数解锁配方
        function checkCustomerCountUnlock() {
            if (!gameData.customerCountUnlockRules) return;

            const servedCount = gameData.servedCustomers;

            Object.keys(gameData.customerCountUnlockRules).forEach(recipeName => {
                const rule = gameData.customerCountUnlockRules[recipeName];

                if (servedCount >= rule.customersRequired &&
                    !Object.keys(gameData.teaRecipes).includes(recipeName)) {

                    // 解锁配方
                    gameData.teaRecipes[recipeName] = rule.ingredients;

                    addDebugLog(`🎉 人数解锁新配方：${recipeName}！(服务${servedCount}位顾客)`);

                    const unlockContent = `
                        <div style="text-align: center; margin-bottom: 15px;">
                            <h3 style="color: #0040c0; margin: 0;">🎉 人数解锁新配方：${recipeName}</h3>
                            <p style="color: #666; margin: 5px 0;">已服务 ${servedCount} 位顾客</p>
                        </div>
                        <div style="text-align: left; line-height: 1.6;">
                            <div style="margin-bottom: 12px; padding: 8px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                                <strong>配方成分：</strong><br>
                                ${rule.ingredients.join(' + ')}
                            </div>
                            <div style="color: #006600;">
                                恭喜您达成服务里程碑！这是对您辛勤经营的奖励。
                            </div>
                        </div>
                    `;
                    showWin95Modal('里程碑奖励', unlockContent, '🏆');

                    // 更新显示
                    updateAllInventoryDisplay();
                }
            });
        }

        // 彩蛋码系统
        function generateEasterEggCode(customerName, visitCount) {
            // 基于设备指纹+时间戳+顾客信息生成
            const deviceFingerprint = navigator.userAgent + screen.width + screen.height;
            const timestamp = Date.now();
            const customerInfo = customerName + visitCount;

            // 简单的哈希函数
            function simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // 转换为32位整数
                }
                return Math.abs(hash);
            }

            const hash = simpleHash(deviceFingerprint + timestamp + customerInfo);

            // 生成格式：XXXX-XXXX-XXXX
            const part1 = (hash % 10000).toString().padStart(4, '0');
            const part2 = ((hash >> 4) % 10000).toString().padStart(4, '0');
            const part3 = ((hash >> 8) % 10000).toString().padStart(4, '0');

            return `${part1}-${part2}-${part3}`;
        }

        function checkEasterEggTrigger(customerName) {
            const visitCount = gameData.customerVisits[customerName] || 0;

            // 访问10次以上触发彩蛋码
            if (visitCount >= 10) {
                const easterEggCode = generateEasterEggCode(customerName, visitCount);

                const easterEggContent = `
                    <div style="text-align: center; margin-bottom: 15px;">
                        <h3 style="color: #ff6b35; margin: 0;">🎁 特殊彩蛋码生成！</h3>
                        <p style="color: #666; margin: 5px 0;">${customerName} 第 ${visitCount} 次访问</p>
                    </div>
                    <div style="text-align: center; line-height: 1.8;">
                        <div style="margin: 15px 0; padding: 12px; background: #fff3cd; border: 2px dashed #ffc107; font-family: monospace; font-size: 12px; font-weight: bold; color: #856404;">
                            ${easterEggCode}
                        </div>
                        <div style="color: #666; font-size: 12px; margin-top: 10px;">
                            这是您与 ${customerName} 深厚友谊的见证！<br>
                            请妥善保存这个独特的纪念码。
                        </div>
                    </div>
                `;

                showWin95Modal('友谊纪念', easterEggContent, '🎁');

                // 给予特殊奖励
                gameData.funds += 500;
                addDebugLog(`🎁 彩蛋码奖励：获得500金币！`);
                document.getElementById('current-funds').textContent = gameData.funds + ' 金币';
            }
        }

        // 直接加工材料
        function directProcessing(material) {
            const recipe = gameData.processingRecipes[material];
            if (!recipe) {
                alert(`${material} 不能直接加工`);
                return;
            }

            if (gameData.inventory[material] < 1) {
                alert(`${material} 库存不足！`);
                return;
            }

            // 找到空闲的加工台
            const availableBoardIndex = gameData.processingBoards.findIndex(board => board.state === 'idle');
            if (availableBoardIndex === -1) {
                alert('所有加工台都在忙，请等待当前加工完成！');
                return;
            }

            if (confirm(`确认加工 ${material}？\n将获得 ${recipe.output} 个 ${material}，耗时 ${Math.round(recipe.time / 1000)} 秒`)) {
                startProcessing(material, availableBoardIndex);
            }
        }

        // 关闭模态框
        document.querySelector('.close').onclick = function() {
            document.getElementById('seed-modal').style.display = 'none';
        }

        document.querySelector('.close-recipe').onclick = function() {
            document.getElementById('recipe-modal').style.display = 'none';
        }

        document.querySelector('.close-processing').onclick = function() {
            document.getElementById('processing-modal').style.display = 'none';
        }

        window.onclick = function(event) {
            const seedModal = document.getElementById('seed-modal');
            const recipeModal = document.getElementById('recipe-modal');
            const processingModal = document.getElementById('processing-modal');
            
            if (event.target === seedModal) {
                seedModal.style.display = 'none';
            }
            if (event.target === recipeModal) {
                recipeModal.style.display = 'none';
            }
            if (event.target === processingModal) {
                processingModal.style.display = 'none';
            }
        }

        // 游戏循环更新
        function gameLoop() {
            // 更新种植进度
            let plotsUpdated = false;
            let hasGrowingPlots = false;
            
            gameData.plots.forEach((plot, index) => {
                if (plot.state === 'growing' && plot.plantType) {
                    hasGrowingPlots = true;
                    const baseGrowTime = seedsInfo[plot.plantType].growTime;

                    // 应用天气影响到生长时间
                    const currentWeather = weathers[gameData.weather];
                    const weatherEffect = weatherGrowthEffects[currentWeather];
                    const growthMultiplier = weatherEffect ? weatherEffect.growthMultiplier : 1.0;
                    const adjustedGrowTime = baseGrowTime / growthMultiplier;

                    const totalElapsed = Date.now() - plot.plantTime;

                    if (totalElapsed >= adjustedGrowTime) {
                        // 生长完成
                        plot.state = 'ready';
                        plot.growthStage = 4;
                        plotsUpdated = true;
                        addDebugLog(`种植区域 ${index + 1} 的 ${plot.plantType} 生长完成，可以收获了！（天气加成：${growthMultiplier.toFixed(1)}x）`);
                    } else {
                        // 更新生长阶段（用于显示进度）
                        const progress = totalElapsed / adjustedGrowTime;
                        const newStage = Math.floor(progress * 4);
                        if (newStage !== plot.growthStage) {
                            plot.growthStage = newStage;
                            plotsUpdated = true;
                        }
                    }
                }
            });
            
            // 如果有生长中的植物，强制更新显示（用于倒计时）
            if (hasGrowingPlots) {
                plotsUpdated = true;
            }
            
            if (plotsUpdated) {
                renderFarmGrid();
            }

            // 更新炉灶进度
            let stoveUpdated = false;
            gameData.stoves.forEach((stove, index) => {
                if (stove.state === 'cooking') {
                    const elapsed = Date.now() - stove.startTime;
                    if (elapsed >= stove.duration) {
                        // 制茶完成
                        const completedRecipe = stove.recipe;
                        const beforeTeaCount = gameData.madeTeas.length;
                        gameData.madeTeas.push({
                            name: stove.recipe,
                            temperature: '热茶',
                            makeTime: new Date().toLocaleTimeString()
                        });
                        const afterTeaCount = gameData.madeTeas.length;
                        
                        stove.state = 'idle';
                        stove.recipe = null;
                        stoveUpdated = true;
                        
                        addDebugLog(`制茶完成：${completedRecipe}，茶饮库存 ${beforeTeaCount} → ${afterTeaCount} (+1)`);
                        
                        // 立即更新所有显示
                        updateAllInventoryDisplay();
                        showWin95Modal('制茶完成', `<div style="text-align: center; line-height: 1.6;"><div style="font-size: 12px; margin-bottom: 8px;">🍵 ${completedRecipe} 制作完成！</div><div style="color: #006600;">已添加到茶饮库存</div></div>`, '🍵');
                    } else {
                        stoveUpdated = true; // 进度更新
                    }
                }
            });
            if (stoveUpdated) renderStoves();

            // 更新打猎倒计时
            if (gameData.huntingSystem) {
                if (gameData.huntingSystem.backMountain && gameData.huntingSystem.backMountain.isHunting) {
                    updateHuntingDisplay();
                }
                if (gameData.huntingSystem.cave && gameData.huntingSystem.cave.isHunting) {
                    updateCaveHuntingDisplay();
                }
            }

            // 更新烤制进度
            if (gameData.grillSystem && gameData.grillSystem.isGrilling) {
                updateGrillProgress();
            }

            // 更新加工台进度
            let processingUpdated = false;
            gameData.processingBoards.forEach((board, index) => {
                if (board.state === 'processing') {
                    const elapsed = Date.now() - board.startTime;
                    if (elapsed >= board.duration) {
                        // 加工完成
                        const recipe = gameData.processingRecipes[board.recipe];
                        const recipeName = board.recipe;

                        // 支持多产出（动物分解）和单产出（小料加工）
                        if (recipe.outputs) {
                            // 多产出模式（动物分解）
                            let resultText = [];
                            recipe.outputs.forEach(output => {
                                if (!gameData.materials[output.name]) {
                                    gameData.materials[output.name] = 0;
                                }
                                const beforeCount = gameData.materials[output.name];
                                gameData.materials[output.name] += output.quantity;
                                const afterCount = gameData.materials[output.name];
                                resultText.push(`${output.name}×${output.quantity}`);
                                addDebugLog(`分解获得：${output.name} ${beforeCount} → ${afterCount} (+${output.quantity})`);
                            });

                            addDebugLog(`案板${index + 1}分解完成：${recipeName} → ${resultText.join(', ')}`);
                            showWin95Modal('分解完成',
                                `<div style="text-align: center; line-height: 1.6;">
                                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">🔧 ${recipeName}完成！</h3>
                                    <div style="margin-bottom: 15px; padding: 12px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                                        <div style="font-weight: bold; color: #d2691e; margin-bottom: 8px;">获得材料：</div>
                                        ${resultText.map(item => `<div style="color: #666;">${item}</div>`).join('')}
                                    </div>
                                </div>`, '🔧');
                        } else {
                            // 单产出模式（小料加工）
                            const beforeCount = gameData.toppings[recipeName] || 0;
                            gameData.toppings[recipeName] = beforeCount + recipe.output;
                            const afterCount = gameData.toppings[recipeName];

                            addDebugLog(`案板${index + 1}加工完成：${recipeName} ${beforeCount} → ${afterCount} (+${recipe.output})`);
                            showAlert(`${recipeName}加工完成！获得 ${recipe.output} 个`, '加工完成', '✅');
                        }

                        board.state = 'idle';
                        board.recipe = null;
                        board.startTime = 0;
                        board.duration = 0;

                        processingUpdated = true;
                        updateAllInventoryDisplay();
                        saveGameDataToDatabase();
                    } else {
                        processingUpdated = true; // 进度更新
                    }
                }
            });
            if (processingUpdated) renderProcessingBoard();

            // 更新顾客和猫咪系统
            updateCustomer();
            trySpawnCustomer();
            
            // 每10秒输出一次系统状态（用于调试）
            if (Date.now() % 10000 < 1000) {
                const teaCount = gameData.madeTeas.length;
                const customerActive = gameData.customer.active;
                const plots = gameData.plots.map(p => p.state).join(',');
                addDebugLog(`系统状态 - 茶饮:${teaCount} 顾客:${customerActive} 地块:${plots}`);
            }
        }

        // 初始化游戏
        function initGame() {
            initializeData();
            renderFarmGrid();
            renderWorkspaces();
            updateAllInventoryDisplay(); // 确保库存显示正确
            
            // 更新所有资金显示元素
            updateAllFundsDisplay();
            
            // 从数据库加载数据
            loadGameDataFromDatabase();
            
            // 启动自动保存
            startAutoSave();
            
            // 启动游戏循环
            setInterval(gameLoop, 1000);

            // 检查稻香村解锁状态
            updateRiceVillageDisplay();

            // 延迟再次检查，确保数据加载完成
            setTimeout(() => {
                console.log('延迟检查稻香村解锁状态...');
                updateRiceVillageDisplay();
            }, 2000);

            addDebugLog('游戏初始化完成');
        }

        // 更新所有资金显示的函数
        function updateAllFundsDisplay() {
            // 更新主要资金显示
            const currentFunds = document.getElementById('current-funds');
            if (currentFunds) currentFunds.textContent = gameData.funds + ' 金币';
            
            // 更新商店资金显示
            const shopFunds = document.getElementById('shop-funds');
            if (shopFunds) shopFunds.textContent = gameData.funds + ' 金币';
            
            // 更新调试面板资金显示
            const debugFunds = document.getElementById('debug-funds');
            if (debugFunds) debugFunds.textContent = gameData.funds + ' 金币';
        }

        // 数据库保存功能
        function saveGameDataToDatabase() {
            const gameState = {
                timestamp: new Date().toISOString(),
                funds: gameData.funds,
                plots: gameData.plots,
                inventory: gameData.inventory,
                seeds: gameData.seeds,
                madeTeas: gameData.madeTeas,
                toppings: gameData.toppings,
                stoves: gameData.stoves,
                processingBoards: gameData.processingBoards,
                customer: gameData.customer,
                cats: gameData.cats,
                customers: gameData.customers,
                servedCustomers: gameData.servedCustomers,
                lastCustomerTime: gameData.lastCustomerTime,
                currentDay: gameData.currentDay,
                seasonDay: gameData.seasonDay,
                season: gameData.season,
                weather: gameData.weather,
                currentSeason: gameData.currentSeason,
                currentWeather: gameData.currentWeather,
                lastDayChange: gameData.lastDayChange,
                selectedCat: gameData.selectedCat,
                customerVisits: gameData.customerVisits,
                // 新增：茶饮配方解锁状态
                teaRecipes: gameData.teaRecipes,
                // 新增：打猎和烤肉架系统状态
                materials: gameData.materials,
                huntingSystem: gameData.huntingSystem,
                grillSystem: gameData.grillSystem
            };
            
            // 保存到localStorage作为备份
            localStorage.setItem('teaGameData', JSON.stringify(gameState));

            // 同时更新槽位1（自动存档）
            localStorage.setItem('teaGameSave_1', JSON.stringify(gameState));
            updateSaveSlotDisplay();

            // 云端同步（异步，不阻塞游戏）
            if (cloudSaveConfig.githubToken && cloudSaveConfig.gistId) {
                // 检查是否需要同步（避免频繁同步）
                const now = Date.now();
                const timeSinceLastSync = now - cloudSaveConfig.lastSyncTime;

                if (timeSinceLastSync > 30000) { // 30秒内最多同步一次
                    syncToCloud(1).catch(error => {
                        addDebugLog(`☁️ 自动云端同步失败: ${error.message}`);
                    });
                }
            }
            
            // 添加调试信息
            addDebugLog(`💾 准备保存到数据库，customerVisits: ${JSON.stringify(gameState.customerVisits)}`);

            // GitHub Pages版本：只使用本地存储和云端同步
            console.log('GitHub Pages版本：数据已保存到本地存储');

            // 更新调试面板状态
            const dbStatus = document.getElementById('db-status');
            if (dbStatus) {
                dbStatus.textContent = 'localStorage';
                dbStatus.className = 'debug-status status-connected';
            }
            const lastSave = document.getElementById('last-save');
            if (lastSave) lastSave.textContent = new Date().toLocaleTimeString();

            addDebugLog('✅ 游戏数据保存到本地存储成功（包含customerVisits）');

            // 更新云端存档状态显示
            const cloudStatus = document.getElementById('cloud-status');
            if (cloudStatus && cloudSaveConfig.githubToken && cloudSaveConfig.gistId) {
                cloudStatus.textContent = '已配置';
                cloudStatus.className = 'debug-status status-connected';
            } else if (cloudStatus) {
                cloudStatus.textContent = '未设置';
                cloudStatus.className = 'debug-status status-loading';
            }
        }
        
        // GitHub Pages版本：从本地存储加载数据
        function loadGameDataFromDatabase() {
            console.log('GitHub Pages版本：从本地存储加载数据');

            // 直接从localStorage加载
            loadFromLocalStorage();

            // 调试customerVisits加载情况
            addDebugLog(`📥 从本地存储加载customerVisits: ${JSON.stringify(gameData.customerVisits || {})}`);

            // 更新调试面板状态
            const dbStatus = document.getElementById('db-status');
            if (dbStatus) {
                dbStatus.textContent = 'localStorage';
                dbStatus.className = 'debug-status status-connected';
            }

            addDebugLog('✅ 从本地存储加载游戏数据成功（包含customerVisits）');

            // 立即更新所有显示
            renderFarmGrid();
            renderWorkspaces();
            updateAllInventoryDisplay();
            const currentFunds = document.getElementById('current-funds');
            if (currentFunds) currentFunds.textContent = gameData.funds + ' 金币';
            updateDebugDisplay();
        }

        // GitHub Pages版本：本地顾客统计同步
        function syncCustomerStatsFromDatabase() {
            addDebugLog('📊 GitHub Pages版本：使用本地顾客统计数据');

            // 确保数据结构完整
            if (!gameData.customerVisits) gameData.customerVisits = {};
            if (!gameData.customers) gameData.customers = {};

            // 更新界面显示
            renderCustomersTable();
            updateAllFundsDisplay();
            updateGrillAndHuntingDisplay();

            addDebugLog('✅ 本地顾客统计数据同步完成');
        }

        function loadFromLocalStorage() {
            const savedData = localStorage.getItem('teaGameData');
            if (savedData) {
                try {
                    const gameState = JSON.parse(savedData);
                    Object.assign(gameData, gameState);
                    console.log('从本地存储加载游戏数据');
                } catch (error) {
                    console.error('本地存储数据解析失败:', error);
                }
            }
        }
        
        // 自动保存功能
        function startAutoSave() {
            setInterval(() => {
                saveGameDataToDatabase();
            }, 30000); // 每30秒自动保存一次
        }

        // 天气和季节系统
        const seasons = ['春天', '夏天', '秋天', '冬天'];
        const seasonsEmoji = ['🌸', '☀️', '🍂', '❄️'];
        const weathers = ['晴天', '多云', '雨天', '暴风雨'];
        const weathersEmoji = ['☀️', '⛅', '🌧️', '⛈️'];
        const weatherEffects = {
            '晴天': '作物生长 +20%',
            '多云': '作物生长 正常',
            '雨天': '作物生长 +10%, 自动浇水',
            '暴风雨': '作物生长 -10%'
        };

        // 天气对农作物的影响系统
        const weatherGrowthEffects = {
            '晴天': { growthMultiplier: 1.2, moistureChange: -5, fertilityChange: 0 },
            '多云': { growthMultiplier: 1.0, moistureChange: -3, fertilityChange: 0 },
            '雨天': { growthMultiplier: 1.1, moistureChange: +15, fertilityChange: +3 },
            '暴风雨': { growthMultiplier: 0.9, moistureChange: +10, fertilityChange: -5 }
        };

        // 推进一天
        function advanceDay() {
            gameData.currentDay++;
            gameData.seasonDay++;
            gameData.lastDayChange = Date.now();

            // 每10天换一个季节（按照设定）
            if (gameData.seasonDay > 10) {
                gameData.seasonDay = 1;
                gameData.season = (gameData.season + 1) % 4;
                addDebugLog(`季节变化：进入${seasons[gameData.season]}`);
            }
            
            // 更新季节和天气文本
            gameData.currentSeason = seasons[gameData.season];
            gameData.currentWeather = weathers[gameData.weather];
            
            // 随机变化天气（30%几率）
            if (Math.random() < 0.3) {
                changeWeather();
            }
            
            addDebugLog(`时间推进：第${gameData.currentDay}天，${gameData.currentSeason}第${gameData.seasonDay}天，${gameData.currentWeather}`);
            updateWeatherAndSeasonDisplay();

            // 应用天气影响到所有种植中的作物
            applyWeatherEffects();

            saveGameDataToDatabase();
        }

        // 应用天气影响到农作物
        function applyWeatherEffects() {
            const currentWeather = weathers[gameData.weather];
            const effects = weatherGrowthEffects[currentWeather];

            if (!effects) return;

            gameData.plots.forEach((plot, index) => {
                if (plot.state === 'growing') {
                    // 应用湿度变化
                    plot.moisture = Math.max(0, Math.min(100, plot.moisture + effects.moistureChange));

                    // 应用肥沃度变化
                    plot.fertility = Math.max(0, Math.min(100, plot.fertility + effects.fertilityChange));

                    addDebugLog(`天气影响 - 田地${index + 1}: 湿度${effects.moistureChange > 0 ? '+' : ''}${effects.moistureChange}%, 肥沃度${effects.fertilityChange > 0 ? '+' : ''}${effects.fertilityChange}%`);
                }
            });

            // 更新显示
            renderFarmGrid();
        }

        // 改变天气
        function changeWeather() {
            const oldWeather = gameData.weather;
            gameData.weather = Math.floor(Math.random() * 4);
            gameData.currentWeather = weathers[gameData.weather];

            // 记录天气变化时间
            gameData.lastWeatherChange = Date.now();

            if (oldWeather !== gameData.weather) {
                addDebugLog(`天气变化：${weathers[oldWeather]} → ${weathers[gameData.weather]} (${weatherEffects[gameData.weather]})`);
                updateWeatherAndSeasonDisplay();

                // 雨天自动浇水效果
                if (gameData.weather === 2) { // 雨天
                    gameData.plots.forEach((plot, index) => {
                        if (plot.state !== 'empty') {
                            plot.moisture = Math.min(100, plot.moisture + 20);
                        }
                    });
                    addDebugLog('🌧️ 雨天自动为所有田地浇水！');
                    renderFarmGrid();
                }
            }
        }

        // 更新天气和季节显示
        function updateWeatherAndSeasonDisplay() {
            // 更新基础信息表格中的显示
            const currentDayElement = document.getElementById('current-day');
            const currentSeasonElement = document.getElementById('current-season');
            const currentWeatherElement = document.getElementById('current-weather');
            
            if (currentDayElement) {
                currentDayElement.textContent = `第${gameData.currentDay}天`;
            }
            
            if (currentSeasonElement) {
                currentSeasonElement.innerHTML = `${gameData.currentSeason} (第${gameData.seasonDay}天)`;
            }
            
            if (currentWeatherElement) {
                const currentWeatherName = weathers[gameData.weather];
                const weatherEffect = weatherEffects[currentWeatherName];
                currentWeatherElement.innerHTML = `<span class="weather-icon">${weathersEmoji[gameData.weather]}</span> ${gameData.currentWeather}<br><small>${weatherEffect}</small>`;
            }
            
            // 更新调试面板中的显示
            updateDebugDisplay();
        }

        // 游戏时间循环（按照设定运行）
        function startGameTimeLoop() {
            // 天气变化循环 - 每1分钟变化一次天气
            setInterval(() => {
                changeWeather();
                addDebugLog('天气自动变化');
            }, 60000); // 1分钟变化一次天气

            // 时间推进循环 - 每30秒有机会推进一天
            setInterval(() => {
                // 每30秒有20%的几率推进一天，让游戏更活跃
                if (Math.random() < 0.2) {
                    advanceDay();
                }
            }, 30000); // 每30秒检查一次

            // 快速时间推进（用于测试和活跃游戏）
            setInterval(() => {
                // 每10秒有5%的几率推进一天
                if (Math.random() < 0.05) {
                    advanceDay();
                }
            }, 10000); // 每10秒检查一次
        }

        // 手动推进时间（调试用）
        function forceAdvanceDay() {
            advanceDay();
            addDebugLog('手动推进了一天');
            alert(`时间推进！现在是第${gameData.currentDay}天，${gameData.currentSeason}第${gameData.seasonDay}天`);
        }

        // 调试面板相关函数
        function toggleDebugContent() {
            const panel = document.getElementById('debug-panel');
            const content = document.getElementById('debug-content');
            const toggle = document.querySelector('.debug-toggle');
            
            if (panel.classList.contains('collapsed')) {
                // 展开到长条状态
                panel.classList.remove('collapsed');
                toggle.textContent = '−';
                addDebugLog('调试面板已展开');
            } else {
                // 缩起来变成圆球
                panel.classList.add('collapsed');
                addDebugLog('调试面板已收起');
            }
        }
        
        function addDebugLog(message) {
            const log = document.getElementById('debug-log');
            if (log) {
                const timestamp = new Date().toLocaleTimeString();
                log.innerHTML += `[${timestamp}] ${message}<br>`;
                log.scrollTop = log.scrollHeight;
            }
        }
        
        function clearDebugLog() {
            const log = document.getElementById('debug-log');
            if (log) log.innerHTML = '日志已清空<br>';
        }

        // 测试函数：立即生成顾客
        function forceSpawnCustomer() {
            if (gameData.customer.active) {
                addDebugLog('当前已有顾客，无法生成新顾客');
                alert('当前已有顾客在等待！');
                return;
            }
            
            spawnRandomCustomer();
            addDebugLog('手动触发：立即生成了一个顾客');
            alert('成功生成顾客！');
        }

        // 测试函数：添加测试材料
        function addTestMaterials() {
            // 添加各种基础材料用于测试
            const testMaterials = ['五味子', '柠檬', '山楂', '桂圆', '红枣', '枸杞', '大麦', '薄荷', '甘草'];
            testMaterials.forEach(material => {
                gameData.inventory[material] = (gameData.inventory[material] || 0) + 10;
            });
            
            // 添加一些种子
            testMaterials.forEach(material => {
                gameData.seeds[material] = (gameData.seeds[material] || 0) + 5;
            });
            
            // 更新显示
            updateAllInventoryDisplay();
            addDebugLog('添加了测试材料：' + testMaterials.join(', ') + '（各10个）');
            alert('已添加测试材料！现在可以尝试制作茶饮了。');
            saveGameDataToDatabase();
        }
        
        function updateDebugDisplay() {
            try {
                // 更新天气和季节显示
                const debugDay = document.getElementById('debug-day');
                if (debugDay) debugDay.textContent = `第${gameData.currentDay}天`;
                
                const debugSeason = document.getElementById('debug-season');
                if (debugSeason) debugSeason.textContent = `${gameData.currentSeason} (第${gameData.seasonDay}天)`;
                
                const debugWeather = document.getElementById('debug-weather');
                if (debugWeather) debugWeather.innerHTML = `<span class="weather-icon">${weathersEmoji[gameData.weather]}</span> ${gameData.currentWeather}`;
                
                // 更新资金显示
                const debugFunds = document.getElementById('debug-funds');
                if (debugFunds) debugFunds.textContent = gameData.funds + ' 金币';
                
                // 计算种子总数
                const totalSeeds = Object.values(gameData.seeds).reduce((sum, count) => sum + count, 0);
                const debugSeeds = document.getElementById('debug-seeds');
                if (debugSeeds) debugSeeds.textContent = totalSeeds + ' 个';
                
                // 计算材料总数
                const totalMaterials = Object.values(gameData.inventory).reduce((sum, count) => sum + count, 0);
                const debugMaterials = document.getElementById('debug-materials');
                if (debugMaterials) debugMaterials.textContent = totalMaterials + ' 个';

                // 更新服务顾客数
                const debugServedCustomers = document.getElementById('debug-served-customers');
                if (debugServedCustomers) debugServedCustomers.textContent = gameData.servedCustomers + ' 位';
                
                // 计算小料总数
                const totalToppings = Object.values(gameData.toppings).reduce((sum, count) => sum + count, 0);
                const debugToppings = document.getElementById('debug-toppings');
                if (debugToppings) debugToppings.textContent = totalToppings + ' 个';
                
                // 更新种植状态
                const debugPlots = document.getElementById('debug-plots');
                if (debugPlots) {
                    debugPlots.innerHTML = '';
                    gameData.plots.forEach((plot, index) => {
                        const plotInfo = document.createElement('div');
                        plotInfo.className = 'debug-item';
                        plotInfo.innerHTML = `
                            <span>地块${index + 1}:</span>
                            <span>${plot.state === 'empty' ? '空闲' : 
                                   plot.state === 'growing' ? `种植${plot.plantType}` : 
                                   `${plot.plantType}可收获`}</span>
                        `;
                        debugPlots.appendChild(plotInfo);
                    });
                }
            } catch (error) {
                console.error('更新调试显示时发生错误:', error);
            }
        }
        
        // GitHub Pages版本：测试本地存储
        function testLocalStorage() {
            addDebugLog('正在测试本地存储...');
            const dbStatus = document.getElementById('db-status');
            if (dbStatus) {
                dbStatus.textContent = '测试中...';
                dbStatus.className = 'debug-status status-loading';
            }

            try {
                // 测试localStorage读写
                const testData = { test: 'GitHub Pages版本', timestamp: Date.now() };
                localStorage.setItem('teaGameTest', JSON.stringify(testData));
                const retrieved = JSON.parse(localStorage.getItem('teaGameTest'));

                if (retrieved && retrieved.test === 'GitHub Pages版本') {
                    if (dbStatus) {
                        dbStatus.textContent = 'localStorage';
                        dbStatus.className = 'debug-status status-connected';
                    }
                    addDebugLog('✅ 本地存储测试成功');

                    // 清理测试数据
                    localStorage.removeItem('teaGameTest');
                } else {
                    throw new Error('数据读取验证失败');
                }
            } catch (error) {
                if (dbStatus) {
                    dbStatus.textContent = '存储失败';
                    dbStatus.className = 'debug-status status-error';
                }
                addDebugLog('❌ 本地存储测试失败: ' + error.message);
            }
        }
        
        function forceSaveGame() {
            addDebugLog('强制保存游戏数据...');
            saveGameDataToDatabase();
            const lastSave = document.getElementById('last-save');
            if (lastSave) lastSave.textContent = new Date().toLocaleTimeString();
        }
        
        function forceLoadGame() {
            addDebugLog('强制加载游戏数据...');
            loadGameDataFromDatabase();
            updateDebugDisplay();
        }

        // 重置游戏数据函数
        function resetGameData() {
            if (confirm('确定要重置所有游戏数据吗？这将清除所有进度，恢复到初始状态（包括1000金币）。此操作不可撤销！')) {
                // 清除本地存储
                localStorage.removeItem('teaGameData');
                
                // 重置gameData为初始状态
                gameData.funds = 1000;
                gameData.currentDay = 1;
                gameData.seasonDay = 1;
                gameData.season = 0;
                gameData.weather = 0;
                gameData.currentSeason = "春天";
                gameData.currentWeather = "晴天";
                gameData.lastDayChange = Date.now();
                gameData.servedCustomers = 0;
                gameData.lastCustomerTime = 0;
                
                // 重置所有数组和对象
                gameData.plots.forEach(plot => {
                    plot.state = 'empty';
                    plot.moisture = 50;
                    plot.fertility = 50;
                    plot.plantType = null;
                    plot.growthStage = 0;
                    plot.stageStartTime = 0;
                });
                
                gameData.stoves.forEach(stove => {
                    stove.state = 'idle';
                    stove.recipe = null;
                    stove.startTime = 0;
                });
                
                gameData.processingBoards.forEach(board => {
                    board.state = 'idle';
                    board.recipe = null;
                    board.startTime = 0;
                    board.duration = 0;
                });
                
                gameData.madeTeas = [];
                
                // 重新初始化数据
                initializeData();
                
                // 更新所有显示
                updateAllFundsDisplay();
                renderFarmGrid();
                renderWorkspaces();
                updateAllInventoryDisplay();
                updateDebugDisplay();
                
                // 保存重置后的数据
                saveGameDataToDatabase();
                
                addDebugLog('游戏数据已重置为初始状态，当前资金: 1000金币');
                alert('游戏数据已重置！当前资金: 1000金币');
            }
        }

        // 小料商店相关函数
        function openToppingsShop() {
            const modal = document.getElementById('toppings-shop-modal');
            const shopFunds = document.getElementById('shop-funds');
            const shopGrid = document.getElementById('toppings-shop-grid');
            
            // 更新资金显示
            if (shopFunds) {
                shopFunds.textContent = gameData.funds + ' 金币';
            }
            
            // 清空并重新生成商品列表
            if (shopGrid) {
                shopGrid.innerHTML = '';
                
                Object.entries(toppingsShop).forEach(([itemName, itemData]) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'topping-item';
                    
                    const currentStock = gameData.toppings[itemName] || 0;
                    const canAfford = gameData.funds >= itemData.price;
                    
                    itemDiv.innerHTML = `
                        <div class="topping-name">${itemName}</div>
                        <div class="topping-price">${itemData.price} 金币</div>
                        <div class="topping-stock">库存: ${currentStock}</div>
                        <div class="topping-description">${itemData.description}</div>
                        <button class="buy-btn" onclick="buyTopping('${itemName}')" ${canAfford ? '' : 'disabled'}>
                            ${canAfford ? '购买' : '资金不足'}
                        </button>
                    `;
                    
                    shopGrid.appendChild(itemDiv);
                });
            }
            
            // 显示模态框
            if (modal) {
                modal.style.display = 'block';
            }
        }

        function buyTopping(itemName) {
            const itemData = toppingsShop[itemName];
            if (!itemData) {
                addDebugLog(`未找到商品：${itemName}`);
                return;
            }
            
            if (gameData.funds < itemData.price) {
                addDebugLog(`资金不足，无法购买${itemName}（需要${itemData.price}金币）`);
                alert('资金不足！');
                return;
            }
            
            // 扣除金币
            gameData.funds -= itemData.price;
            
            // 增加小料库存
            if (!gameData.toppings[itemName]) {
                gameData.toppings[itemName] = 0;
            }
            gameData.toppings[itemName] += 1;
            
            // 更新显示
            updateAllInventoryDisplay();
            document.getElementById('current-funds').textContent = gameData.funds + ' 金币';
            
            // 重新打开商店以刷新显示
            openToppingsShop();
            
            addDebugLog(`购买了 ${itemName}，花费 ${itemData.price} 金币`);
            
            // 保存数据
            saveGameDataToDatabase();
        }

        function closeToppingsShop() {
            const modal = document.getElementById('toppings-shop-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // 售卖动物副产品
        function sellByproduct(itemName) {
            if (!gameData.materials || !gameData.materials[itemName] || gameData.materials[itemName] <= 0) {
                showAlert('没有可售卖的物品！', '售卖失败', '❌');
                return;
            }

            const byproduct = animalByproducts[itemName];
            if (!byproduct) {
                showAlert('该物品不可售卖！', '售卖失败', '❌');
                return;
            }

            // 确认售卖
            const sellContent = `
                <div style="text-align: center; line-height: 1.6;">
                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">💰 确认售卖</h3>
                    <div style="margin-bottom: 15px; padding: 12px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                        <div style="font-weight: bold; color: #d2691e; margin-bottom: 8px;">${itemName}</div>
                        <div style="color: #666; font-size: 14px; margin-bottom: 8px;">当前库存: ${gameData.materials[itemName]}个</div>
                        <div style="color: #22c55e; font-weight: bold;">售价: ${byproduct.price}金币/个</div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <button style="width: 48%; padding: 8px; margin-right: 4%; background: #22c55e; color: white; border: 1px solid #16a34a; cursor: pointer;"
                                onclick="confirmSellByproduct('${itemName}', 1); closeModal();">
                            售卖1个
                        </button>
                        <button style="width: 48%; padding: 8px; background: #3b82f6; color: white; border: 1px solid #2563eb; cursor: pointer;"
                                onclick="confirmSellByproduct('${itemName}', ${gameData.materials[itemName]}); closeModal();">
                            全部售卖
                        </button>
                    </div>
                </div>
            `;

            showWin95Modal('售卖副产品', sellContent, '💰');
        }

        // 确认售卖副产品
        function confirmSellByproduct(itemName, quantity) {
            if (!gameData.materials || !gameData.materials[itemName] || gameData.materials[itemName] < quantity) {
                showAlert('库存不足！', '售卖失败', '❌');
                return;
            }

            const byproduct = animalByproducts[itemName];
            const totalPrice = byproduct.price * quantity;

            // 扣除物品，增加金币
            const beforeCount = gameData.materials[itemName];
            gameData.materials[itemName] = Math.max(0, beforeCount - quantity);
            const afterCount = gameData.materials[itemName];

            gameData.funds += totalPrice;

            addDebugLog(`💰 售卖${itemName}×${quantity}，获得${totalPrice}金币`);
            addDebugLog(`  - ${itemName}: ${beforeCount} → ${afterCount} (-${quantity})`);
            addDebugLog(`  - 金币: ${gameData.funds - totalPrice} → ${gameData.funds} (+${totalPrice})`);

            showAlert(`成功售卖${itemName}×${quantity}，获得${totalPrice}金币！`, '售卖成功', '💰');

            // 更新显示
            updateAllInventoryDisplay();
            updateAllFundsDisplay();
            saveGameDataToDatabase();
        }

        // ===== 云端存储功能 =====

        // 显示云端存储设置界面
        function showCloudSaveSettings() {
            const currentToken = cloudSaveConfig.githubToken;
            const currentGistId = cloudSaveConfig.gistId;
            const isConnected = currentToken && currentGistId;

            const settingsContent = `
                <div style="text-align: left; line-height: 1.6; max-width: 500px;">
                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">☁️ 云端存档设置</h3>

                    <div style="margin-bottom: 15px; padding: 12px; background: ${isConnected ? '#f0f8ff' : '#fff8dc'}; border: 1px inset #c0c0c0;">
                        <div style="font-weight: bold; margin-bottom: 8px;">
                            状态: ${isConnected ? '✅ 已连接到云端' : '⚠️ 未连接云端'}
                        </div>
                        ${isConnected ? `<div style="font-size: 12px; color: #666;">Gist ID: ${currentGistId}</div>` : ''}
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">GitHub Personal Access Token:</label>
                        <input type="password" id="github-token-input" value="${currentToken}"
                               placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
                               style="width: 100%; padding: 8px; border: 1px solid #ccc; font-family: monospace; font-size: 12px;">
                        <small style="color: #666; display: block; margin-top: 5px;">
                            需要 'gist' 权限，<a href="#" onclick="showTokenHelp()">如何创建Token？</a>
                        </small>
                    </div>

                    <div style="margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="testGitHubConnection()" style="padding: 8px 16px; background: #22c55e; color: white; border: none; cursor: pointer;">
                            测试连接
                        </button>
                        <button onclick="saveCloudSettings()" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; cursor: pointer;">
                            保存设置
                        </button>
                        ${isConnected ? `
                        <button onclick="syncToCloud()" style="padding: 8px 16px; background: #f59e0b; color: white; border: none; cursor: pointer;">
                            立即同步
                        </button>` : ''}
                    </div>

                    <div id="cloud-connection-status" style="margin-top: 15px; padding: 8px; background: #f9f9f9; border: 1px inset #c0c0c0; min-height: 20px;">
                        ${isConnected ? '云端存档已就绪，游戏数据会自动同步到GitHub Gist' : '请设置GitHub Token以启用云端存档功能'}
                    </div>

                    <div style="margin-top: 15px; font-size: 12px; color: #666; line-height: 1.4;">
                        <strong>说明：</strong><br>
                        • 云端存档完全免费，数据存储在你的GitHub账号中<br>
                        • 支持多设备同步，任何地方都能继续游戏<br>
                        • Token只需要'gist'权限，安全可控<br>
                        • 即使不设置云端存档，游戏也会保存在本地浏览器中
                    </div>
                </div>
            `;

            showWin95Modal('云端存档设置', settingsContent, '☁️');
        }

        // 显示Token创建帮助
        function showTokenHelp() {
            const helpContent = `
                <div style="text-align: left; line-height: 1.6; max-width: 600px;">
                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">📝 如何创建GitHub Token</h3>

                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #d2691e; margin: 10px 0 5px 0;">步骤1：进入GitHub设置</h4>
                        <ol style="margin: 0; padding-left: 20px;">
                            <li>访问 <a href="https://github.com" target="_blank">github.com</a> 并登录</li>
                            <li>点击右上角头像 → Settings</li>
                            <li>左侧菜单 → Developer settings</li>
                            <li>Personal access tokens → Tokens (classic)</li>
                        </ol>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #d2691e; margin: 10px 0 5px 0;">步骤2：创建新Token</h4>
                        <ol style="margin: 0; padding-left: 20px;">
                            <li>点击 "Generate new token" → "Generate new token (classic)"</li>
                            <li>Note: 填写 "Farm Game Data Storage"</li>
                            <li>Expiration: 选择 "No expiration"</li>
                            <li>权限只勾选: <strong>✅ gist</strong></li>
                            <li>点击 "Generate token"</li>
                        </ol>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #d2691e; margin: 10px 0 5px 0;">步骤3：复制Token</h4>
                        <div style="padding: 10px; background: #fff8dc; border: 1px solid #ddd;">
                            <strong>重要：</strong>生成后立即复制Token（类似 ghp_xxxxxxxxxxxxxxxxxxxx），
                            页面刷新后就看不到了！
                        </div>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <h4 style="color: #d2691e; margin: 10px 0 5px 0;">步骤4：在游戏中使用</h4>
                        <ol style="margin: 0; padding-left: 20px;">
                            <li>将Token粘贴到上面的输入框中</li>
                            <li>点击"测试连接"验证</li>
                            <li>点击"保存设置"完成配置</li>
                        </ol>
                    </div>

                    <div style="padding: 10px; background: #f0f8ff; border: 1px solid #ddd; font-size: 12px;">
                        <strong>安全提示：</strong><br>
                        • Token只有'gist'权限，无法访问你的代码仓库<br>
                        • 可以随时在GitHub设置中删除Token<br>
                        • Token保存在你的浏览器本地，不会上传到任何服务器
                    </div>

                    <div style="text-align: center; margin-top: 15px;">
                        <button onclick="window.open('https://github.com/settings/tokens', '_blank')"
                                style="padding: 10px 20px; background: #22c55e; color: white; border: none; cursor: pointer;">
                            🚀 打开GitHub Token页面
                        </button>
                    </div>
                </div>
            `;

            showWin95Modal('GitHub Token创建教程', helpContent, '📝');
        }

        // 测试GitHub连接
        async function testGitHubConnection() {
            const tokenInput = document.getElementById('github-token-input');
            const statusDiv = document.getElementById('cloud-connection-status');

            if (!tokenInput || !tokenInput.value.trim()) {
                statusDiv.innerHTML = '❌ 请先输入GitHub Token';
                statusDiv.style.background = '#ffe6e6';
                return;
            }

            const token = tokenInput.value.trim();
            statusDiv.innerHTML = '🔄 正在测试连接...';
            statusDiv.style.background = '#fff8dc';

            try {
                // 测试Token是否有效
                const response = await fetch('https://api.github.com/user', {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const userData = await response.json();

                statusDiv.innerHTML = `✅ 连接成功！GitHub用户: ${userData.login}`;
                statusDiv.style.background = '#f0f8ff';

                addDebugLog(`✅ GitHub连接测试成功，用户: ${userData.login}`);

            } catch (error) {
                statusDiv.innerHTML = `❌ 连接失败: ${error.message}`;
                statusDiv.style.background = '#ffe6e6';
                addDebugLog(`❌ GitHub连接测试失败: ${error.message}`);
            }
        }

        // 保存云端设置
        async function saveCloudSettings() {
            const tokenInput = document.getElementById('github-token-input');
            const statusDiv = document.getElementById('cloud-connection-status');

            if (!tokenInput || !tokenInput.value.trim()) {
                statusDiv.innerHTML = '❌ 请先输入GitHub Token';
                statusDiv.style.background = '#ffe6e6';
                return;
            }

            const token = tokenInput.value.trim();
            statusDiv.innerHTML = '🔄 正在保存设置...';
            statusDiv.style.background = '#fff8dc';

            try {
                // 保存Token到本地
                cloudSaveConfig.githubToken = token;
                localStorage.setItem('githubToken', token);

                // 如果没有Gist ID，创建新的Gist
                if (!cloudSaveConfig.gistId) {
                    const gistId = await createGameDataGist(token);
                    cloudSaveConfig.gistId = gistId;
                    localStorage.setItem('gistId', gistId);
                }

                // 立即同步当前游戏数据
                await syncToCloud();

                statusDiv.innerHTML = '✅ 设置保存成功！云端存档已启用';
                statusDiv.style.background = '#f0f8ff';

                addDebugLog('✅ 云端存档设置保存成功');

                // 关闭设置窗口
                setTimeout(() => {
                    closeModal();
                    showAlert('云端存档已启用！游戏数据将自动同步到GitHub', '设置成功', '☁️');
                }, 1500);

            } catch (error) {
                statusDiv.innerHTML = `❌ 保存失败: ${error.message}`;
                statusDiv.style.background = '#ffe6e6';
                addDebugLog(`❌ 云端存档设置失败: ${error.message}`);
            }
        }

        // 创建游戏数据Gist
        async function createGameDataGist(token) {
            const gistData = {
                description: "Farm Game Save Data - 可爱茶铺农场管理系统存档",
                public: false, // 私有Gist
                files: {
                    "save1.json": {
                        content: JSON.stringify({
                            ...gameData,
                            timestamp: new Date().toISOString(),
                            saveSlot: 1,
                            description: "存档槽1 - 自动保存"
                        }, null, 2)
                    },
                    "save2.json": {
                        content: JSON.stringify({
                            timestamp: new Date().toISOString(),
                            saveSlot: 2,
                            description: "存档槽2 - 空存档",
                            empty: true
                        }, null, 2)
                    },
                    "save3.json": {
                        content: JSON.stringify({
                            timestamp: new Date().toISOString(),
                            saveSlot: 3,
                            description: "存档槽3 - 空存档",
                            empty: true
                        }, null, 2)
                    },
                    "save4.json": {
                        content: JSON.stringify({
                            timestamp: new Date().toISOString(),
                            saveSlot: 4,
                            description: "存档槽4 - 空存档",
                            empty: true
                        }, null, 2)
                    },
                    "README.md": {
                        content: `# 可爱茶铺农场管理系统 - 游戏存档

这个Gist存储了你的游戏存档数据。

## 存档说明
- save1.json: 存档槽1 (自动保存)
- save2.json: 存档槽2 (手动存档)
- save3.json: 存档槽3 (手动存档)
- save4.json: 存档槽4 (手动存档)

## 注意事项
- 请不要手动修改这些文件
- 游戏会自动同步数据到这里
- 如需备份，可以下载整个Gist

生成时间: ${new Date().toLocaleString()}
`
                    }
                }
            };

            const response = await fetch('https://api.github.com/gists', {
                method: 'POST',
                headers: {
                    'Authorization': `token ${token}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/vnd.github.v3+json'
                },
                body: JSON.stringify(gistData)
            });

            if (!response.ok) {
                throw new Error(`创建Gist失败: HTTP ${response.status}`);
            }

            const gist = await response.json();
            addDebugLog(`✅ 创建游戏存档Gist成功，ID: ${gist.id}`);

            return gist.id;
        }

        // 同步到云端
        async function syncToCloud(saveSlot = 1) {
            if (!cloudSaveConfig.githubToken || !cloudSaveConfig.gistId) {
                addDebugLog('❌ 云端存档未配置，跳过同步');
                return false;
            }

            if (cloudSaveConfig.syncInProgress) {
                addDebugLog('⏳ 同步正在进行中，跳过本次同步');
                return false;
            }

            cloudSaveConfig.syncInProgress = true;

            try {
                const saveData = {
                    ...gameData,
                    timestamp: new Date().toISOString(),
                    saveSlot: saveSlot,
                    description: `存档槽${saveSlot} - ${saveSlot === 1 ? '自动保存' : '手动存档'}`,
                    syncTime: Date.now()
                };

                const response = await fetch(`https://api.github.com/gists/${cloudSaveConfig.gistId}`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `token ${cloudSaveConfig.githubToken}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/vnd.github.v3+json'
                    },
                    body: JSON.stringify({
                        files: {
                            [`save${saveSlot}.json`]: {
                                content: JSON.stringify(saveData, null, 2)
                            }
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error(`同步失败: HTTP ${response.status}`);
                }

                cloudSaveConfig.lastSyncTime = Date.now();
                addDebugLog(`☁️ 存档${saveSlot}同步到云端成功`);
                return true;

            } catch (error) {
                addDebugLog(`❌ 云端同步失败: ${error.message}`);
                return false;
            } finally {
                cloudSaveConfig.syncInProgress = false;
            }
        }

        // 从云端加载
        async function loadFromCloud(saveSlot = 1) {
            if (!cloudSaveConfig.githubToken || !cloudSaveConfig.gistId) {
                addDebugLog('❌ 云端存档未配置，无法加载');
                return false;
            }

            try {
                const response = await fetch(`https://api.github.com/gists/${cloudSaveConfig.gistId}`, {
                    headers: {
                        'Authorization': `token ${cloudSaveConfig.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`加载失败: HTTP ${response.status}`);
                }

                const gist = await response.json();
                const saveFile = gist.files[`save${saveSlot}.json`];

                if (!saveFile) {
                    throw new Error(`存档槽${saveSlot}不存在`);
                }

                const saveData = JSON.parse(saveFile.content);

                if (saveData.empty) {
                    addDebugLog(`存档槽${saveSlot}为空存档`);
                    return false;
                }

                // 备份当前数据到localStorage
                localStorage.setItem('gameDataBackup', JSON.stringify(gameData));

                // 加载云端数据
                Object.assign(gameData, saveData);

                // 更新所有显示
                updateAllDisplays();

                addDebugLog(`☁️ 从云端加载存档${saveSlot}成功`);
                return true;

            } catch (error) {
                addDebugLog(`❌ 从云端加载失败: ${error.message}`);
                return false;
            }
        }

        // 更新所有显示
        function updateAllDisplays() {
            renderFarmGrid();
            renderWorkspaces();
            updateAllInventoryDisplay();
            updateAllFundsDisplay();
            updateDebugDisplay();
            updateCustomerDisplay();
            updateGrillAndHuntingDisplay();
        }

        // 服务烤肉类食品给顾客
        function serveGrilledFood() {
            addDebugLog('🍽️ serveGrilledFood函数被调用');

            if (!gameData.customer.active) {
                addDebugLog('❌ 当前没有活跃顾客');
                return;
            }

            if (gameData.customer.orderType !== 'grilled') {
                addDebugLog(`❌ 顾客订单类型不是烤肉：${gameData.customer.orderType}`);
                return;
            }

            const requiredFood = gameData.customer.grilledChoice;
            addDebugLog(`🔍 顾客需要：${requiredFood}`);
            addDebugLog(`🔍 当前库存：${JSON.stringify(gameData.madeTeas.filter(tea => tea.type === 'grilled'))}`);

            // 查找对应的烤肉类食品
            const foodIndex = gameData.madeTeas.findIndex(tea =>
                tea.type === 'grilled' && tea.name === requiredFood);

            addDebugLog(`🔍 找到食品索引：${foodIndex}`);

            if (foodIndex === -1) {
                addDebugLog(`❌ 没有找到${requiredFood}！`);
                showAlert(`没有${requiredFood}，请先制作！`, '服务失败', '❌');
                return;
            }

            const food = gameData.madeTeas[foodIndex];

            // 先保存顾客信息（因为resetCustomer会清除）
            const customerName = gameData.customer.name;
            const isVIP = gameData.customer.isVIP;

            // 移除食品
            gameData.madeTeas.splice(foodIndex, 1);

            // 计算收入（烤肉类食品有1.2倍价格+小费）
            const basePrice = food.basePrice || 25;
            const tip = Math.floor(Math.random() * 5) + 1; // 1-5金币小费
            const totalEarning = basePrice + tip;

            gameData.funds += totalEarning;

            // 记录顾客访问
            recordCustomerVisit(customerName, isVIP);

            addDebugLog(`🍽️ 服务${customerName}：${requiredFood}，获得${totalEarning}金币（含${tip}金币小费）`);

            // 立即重置顾客状态，避免界面显示问题
            resetCustomer();

            // 立即更新显示，确保界面状态正确
            updateAllInventoryDisplay();
            updateAllFundsDisplay();
            updateCustomerDisplay(); // 确保顾客状态显示正确

            // 显示服务成功信息
            const serviceContent = `
                <div style="text-align: center; line-height: 1.6;">
                    <h3 style="color: #0040c0; margin: 0 0 15px 0;">🍽️ 服务成功！</h3>
                    <div style="margin-bottom: 15px; padding: 12px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                        <div style="font-weight: bold; color: #d2691e; margin-bottom: 8px;">顾客：${customerName}</div>
                        <div style="color: #666; margin-bottom: 8px;">订单：${requiredFood}</div>
                        <div style="color: #22c55e; font-weight: bold;">收入：${basePrice}金币 + ${tip}金币小费 = ${totalEarning}金币</div>
                    </div>
                </div>
            `;

            showWin95Modal('服务完成', serviceContent, '🍽️');

            saveGameDataToDatabase();
        }

        // 顶部菜单控制函数
        function toggleInventoryTable(type) {
            let sectionId;
            if (type === 'materials') {
                sectionId = 'materials-section';
            } else if (type === 'toppings') {
                sectionId = 'toppings-section';
            }
            
            const section = document.getElementById(sectionId);
            if (section) {
                if (section.classList.contains('active')) {
                    section.classList.remove('active');
                } else {
                    // 先隐藏其他所有可折叠区域
                    document.querySelectorAll('.collapsible-section').forEach(s => s.classList.remove('active'));
                    // 然后显示当前区域
                    section.classList.add('active');
                    // 滚动到区域顶部
                    setTimeout(() => {
                        section.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                }
            }
        }

        function toggleCustomerTable() {
            const section = document.getElementById('customer-section');
            if (section) {
                if (section.classList.contains('active')) {
                    section.classList.remove('active');
                } else {
                    // 先隐藏其他所有可折叠区域
                    document.querySelectorAll('.collapsible-section').forEach(s => s.classList.remove('active'));
                    // 然后显示当前区域
                    section.classList.add('active');
                    // 滚动到区域顶部
                    setTimeout(() => {
                        section.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                }
            }
        }

        // 调试面板控制函数

        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 立即初始化调试面板
            addDebugLog('🚀 可爱茶铺 GitHub Pages版本启动中...');
            addDebugLog(`版本: ${VERSION_INFO.version} (${VERSION_INFO.build})`);
            addDebugLog('✅ 已移除后端依赖，使用本地存储+云端同步');
            
            initGame();
            
            // 加载保存的数据（会自动测试数据库连接）
            loadGameDataFromDatabase();

            // 尝试从云端加载最新数据
            if (cloudSaveConfig.githubToken && cloudSaveConfig.gistId) {
                addDebugLog('☁️ 检测到云端存档配置，尝试加载最新数据...');
                loadFromCloud(1).then(success => {
                    if (success) {
                        addDebugLog('☁️ 云端数据加载成功');
                        showAlert('已从云端加载最新存档！', '云端同步', '☁️');
                    } else {
                        addDebugLog('☁️ 云端数据加载失败，使用本地数据');
                    }
                }).catch(error => {
                    addDebugLog(`☁️ 云端数据加载错误: ${error.message}`);
                });
            }
            
            // 开始自动保存
            startAutoSave();
            
            // 开始游戏时间循环
            startGameTimeLoop();
            
            // 初始化天气和季节显示
            updateWeatherAndSeasonDisplay();

            // 初始化存档槽位显示
            initSaveSlots();
            
            // 设置小料商店关闭事件
            const closeToppingsShopBtn = document.querySelector('.close-toppings-shop');
            if (closeToppingsShopBtn) {
                closeToppingsShopBtn.addEventListener('click', closeToppingsShop);
            }
            
            // 点击模态框外部关闭小料商店
            const toppingsShopModal = document.getElementById('toppings-shop-modal');
            if (toppingsShopModal) {
                toppingsShopModal.addEventListener('click', function(e) {
                    if (e.target === toppingsShopModal) {
                        closeToppingsShop();
                    }
                });
            }
            
            // 监听网络状态变化
            window.addEventListener('online', function() {
                cloudSaveConfig.isOnline = true;
                addDebugLog('🌐 网络连接已恢复，云端同步功能可用');

                // 网络恢复后尝试同步
                if (cloudSaveConfig.githubToken && cloudSaveConfig.gistId) {
                    setTimeout(() => {
                        syncToCloud(1).catch(error => {
                            addDebugLog(`☁️ 网络恢复后同步失败: ${error.message}`);
                        });
                    }, 2000);
                }
            });

            window.addEventListener('offline', function() {
                cloudSaveConfig.isOnline = false;
                addDebugLog('🌐 网络连接已断开，云端同步暂停');
            });

            // 延迟一点确保界面完全加载
            setTimeout(() => {
                addDebugLog('🎮 可爱茶铺 GitHub Pages版本启动完成');
                addDebugLog('💾 自动保存已启动，每30秒保存到本地存储');
                addDebugLog('🛒 小料商店系统已就绪');
                addDebugLog('🔧 所有游戏功能正常，无后端依赖');

                // 显示云端存档状态
                if (cloudSaveConfig.githubToken && cloudSaveConfig.gistId) {
                    addDebugLog('☁️ 云端存档已配置，数据将自动同步到GitHub');
                } else {
                    addDebugLog('💡 提示：可在调试面板中设置云端存档，实现多设备同步');
                }
            }, 500);
        });

        // Win95风格弹窗系统
        function showWin95Modal(title, content, icon = 'ℹ️', buttons = null) {
            const overlay = document.getElementById('win95-modal-overlay');
            const modal = document.getElementById('win95-modal');
            const titleElement = document.getElementById('win95-modal-title-text');
            const iconElement = document.getElementById('win95-modal-icon');
            const contentElement = document.getElementById('win95-modal-content');
            const buttonsElement = document.getElementById('win95-modal-buttons');

            titleElement.textContent = title;
            iconElement.textContent = icon;
            contentElement.innerHTML = content;

            // 设置按钮
            if (buttons) {
                buttonsElement.innerHTML = '';
                buttons.forEach(button => {
                    const btn = document.createElement('button');
                    btn.className = `win95-button ${button.primary ? 'primary' : ''}`;
                    btn.textContent = button.text;
                    btn.onclick = button.onclick;
                    buttonsElement.appendChild(btn);
                });
            } else {
                buttonsElement.innerHTML = '<button class="win95-button primary" onclick="closeWin95Modal()">确定</button>';
            }

            overlay.style.display = 'flex';

            // 添加键盘支持
            const handleKeyPress = (e) => {
                if (e.key === 'Escape') {
                    closeWin95Modal();
                    document.removeEventListener('keydown', handleKeyPress);
                }
            };
            document.addEventListener('keydown', handleKeyPress);
        }

        function closeWin95Modal() {
            const overlay = document.getElementById('win95-modal-overlay');
            overlay.style.display = 'none';
        }

        // 替换原有的alert函数
        function showAlert(message, title = '系统消息', icon = 'ℹ️') {
            showWin95Modal(title, message, icon);
        }

        function showConfirm(message, title = '确认操作', onConfirm = null, onCancel = null) {
            const buttons = [
                {
                    text: '确定',
                    primary: true,
                    onclick: () => {
                        closeWin95Modal();
                        if (onConfirm) onConfirm();
                    }
                },
                {
                    text: '取消',
                    onclick: () => {
                        closeWin95Modal();
                        if (onCancel) onCancel();
                    }
                }
            ];
            showWin95Modal(title, message, '❓', buttons);
        }

        // 显示顾客故事
        function showCustomerStory(customerName) {
            const story = gameData.customerStories[customerName];
            if (!story) {
                showAlert(`${customerName} 的故事尚未解锁`, '故事系统', '📖');
                return;
            }

            const storyContent = `
                <div style="text-align: left; line-height: 1.6;">
                    <h3 style="margin: 0 0 10px 0; color: #0040c0;">${story.title}</h3>
                    <div style="margin-bottom: 12px; padding: 8px; background: #f0f0f0; border: 1px inset #c0c0c0;">
                        ${story.content}
                    </div>
                    <div style="margin-bottom: 8px;">
                        <strong>茶饮功效：</strong><br>
                        <span style="color: #006600;">${story.effect}</span>
                    </div>
                    <div>
                        <strong>人物特征：</strong><br>
                        <span style="color: #800080;">${story.character}</span>
                    </div>
                </div>
            `;

            showWin95Modal(`${customerName} 的故事`, storyContent, '📖');
        }
    </script>
</body>
</html>